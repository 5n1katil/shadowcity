<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Shadow City — Host</title>
  <link rel="stylesheet" href="./styles.css"/>
</head>
<body>
  <div class="shell">
    <header class="topbar">
      <div class="brand">
        <div class="brand__title">SHADOW CITY — HOST</div>
        <div class="brand__subtitle">Moderatör ekranı (TV/PC)</div>
      </div>
      <a class="pill" href="./index.html">↩ Ana Menü</a>
    </header>

    <main class="grid2">
      <!-- Left: Setup -->
      <section class="card stack">
        <h2 class="h2">Oda</h2>

        <div class="notice">
          <div class="muted tiny">Oda Kodu</div>
          <div class="big" id="roomCodeText">—</div>
          <div class="tiny muted">Oyuncular şu adresten girsin: <strong>/player.html</strong></div>
        </div>

        <div class="row">
          <div>
            <label>Host adı (opsiyonel)</label>
            <input id="hostName" placeholder="HOST" value="HOST"/>
          </div>
          <div>
            <label>Oda oluştur</label>
            <button class="btn btn-primary" id="btnCreateRoom">ODA OLUŞTUR</button>
          </div>
        </div>

        <div class="hr"></div>

        <h2 class="h2">Oyun Ayarları</h2>

        <div class="row">
          <div>
            <label>Katil sayısı</label>
            <select id="killerCount">
              <option value="1">1</option>
              <option value="2">2</option>
            </select>
          </div>
          <div>
            <label>Dedektif</label>
            <select id="includeDetective">
              <option value="true">Var</option>
              <option value="false">Yok</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Doktor</label>
            <select id="includeDoctor">
              <option value="true">Var</option>
              <option value="false">Yok</option>
            </select>
          </div>
          <div>
            <label>Tartışma süresi (sn)</label>
            <input id="discussionSec" value="120" />
          </div>
        </div>

        <div class="row">
          <div>
            <label>Gece aksiyon süresi (sn)</label>
            <input id="nightSec" value="45" />
          </div>
          <div>
            <label>Oylama süresi (sn)</label>
            <input id="voteSec" value="45" />
          </div>
        </div>

        <button class="btn btn-ghost" id="btnSaveSettings" disabled>AYARLARI KAYDET</button>

        <div class="hr"></div>

        <h2 class="h2">Kontroller</h2>
        <div class="grid2">
          <button class="btn btn-primary" id="btnStartGame" disabled>ROL DAĞIT & BAŞLAT</button>
          <button class="btn btn-danger" id="btnForceNight" disabled>GECEYİ BAŞLAT</button>
        </div>

        <div class="grid2">
          <button class="btn btn-ghost" id="btnStartVote" disabled>OYLAMA BAŞLAT (OPS.)</button>
          <button class="btn btn-ghost" id="btnSkipVote" disabled>OYLAMAYI ATLA</button>
        </div>

        <div class="hr"></div>

        <div class="notice" id="hostNarration">
          <strong>Anons:</strong>
          <div class="muted" id="hostText">Oda oluşturulmadı.</div>
        </div>
      </section>

      <!-- Right: Players + status -->
      <section class="card stack">
        <h2 class="h2">Durum</h2>

        <div class="kpi">
          <div class="box">
            <div class="num" id="kpiAlive">0</div>
            <div class="lbl">Hayatta</div>
          </div>
          <div class="box">
            <div class="num" id="kpiDead">0</div>
            <div class="lbl">Elendi</div>
          </div>
          <div class="box">
            <div class="num" id="kpiPhase">—</div>
            <div class="lbl">Faz</div>
          </div>
          <div class="box">
            <div class="num" id="kpiDay">—</div>
            <div class="lbl">Gün</div>
          </div>
        </div>

        <h2 class="h2">Oyuncular</h2>
        <div class="list" id="playersList"></div>

        <div class="hr"></div>

        <h2 class="h2">Oylama Çağrıları</h2>
        <div class="notice">
          <div class="muted tiny">Oyuncular “Oylama istiyorum” gönderebilir. Çoğunluk olursa başlatmayı tercih edebilirsin.</div>
          <div class="row" style="margin-top:10px">
            <div class="pill" id="voteCallCount">0 istek</div>
            <div class="pill" id="voteCallMajority">— / —</div>
          </div>
        </div>

      </section>
    </main>
  </div>

  <script type="module">
    import {
      ensureAuth,
      generateRoomCode,
      joinRoomAsHost,
      roomRef,
      settingsRef,
      stateRef,
      playersRef,
      playerRef,
      myRoleRef,
      voteCallRequestsRef,
      votingVotesRef,
      nightActionsRef,
      nightResultsRef,
      listen,
      set,
      update,
      get,
      ref,
    } from "./firebase.js";

    import {
      ROLES,
      ROLE_LABEL_TR,
      speakTR,
      clampInt,
      makeRoleDeck,
      aliveUids,
      computeWin,
      strictMajority,
      pickMostVoted,
      nowMs
    } from "./shared.js";

    let roomCode = null;
    let creatorUid = null;

    let players = {}; // players/{uid}
    let rolesByUid = {}; // secret/roles snapshot (host will also keep a local copy after deal)
    let settings = null;

    const el = (id) => document.getElementById(id);

    function setHostText(text, speak = false){
      el("hostText").textContent = text;
      if (speak) speakTR(text);
    }

    function getSettingsFromUI(){
      return {
        killerCount: clampInt(el("killerCount").value, 1, 3, 1),
        includeDetective: el("includeDetective").value === "true",
        includeDoctor: el("includeDoctor").value === "true",
        discussionSec: clampInt(el("discussionSec").value, 15, 9999, 120),
        nightSec: clampInt(el("nightSec").value, 10, 9999, 45),
        voteSec: clampInt(el("voteSec").value, 10, 9999, 45)
      };
    }

    function renderPlayers(){
      const list = el("playersList");
      const entries = Object.entries(players || {}).filter(([,p]) => p && !p.isHost);

      let alive = 0, dead = 0;
      const rows = entries.map(([uid, p]) => {
        if (p.alive) alive++; else dead++;
        return `
          <div class="item">
            <div>
              <div><strong>${escapeHtml(p.name || "Player")}</strong></div>
              <div class="tiny muted">${uid.slice(0,6)}…</div>
            </div>
            <div class="badge ${p.alive ? "badge--alive":"badge--dead"}">
              ${p.alive ? "Alive" : "Dead"}
            </div>
          </div>
        `;
      }).join("");

      list.innerHTML = rows || `<div class="item"><div class="muted">Henüz oyuncu yok.</div></div>`;

      el("kpiAlive").textContent = String(alive);
      el("kpiDead").textContent = String(dead);
    }

    function escapeHtml(s){
      return String(s || "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#39;");
    }

    function setPhaseUI(state){
      el("kpiPhase").textContent = state?.phase || "—";
      el("kpiDay").textContent = state?.day ? String(state.day) : "—";
    }

    function updateVoteCallUI(voteCallRequests){
      const aliveCount = aliveUids(players).length;
      const maj = strictMajority(aliveCount);
      const reqCount = Object.keys(voteCallRequests || {}).length;

      el("voteCallCount").textContent = `${reqCount} istek`;
      el("voteCallMajority").textContent = `${reqCount} / ${maj} çoğunluk`;
    }

    async function createRoom(){
      await ensureAuth();
      creatorUid = (await ensureAuth()).uid;

      roomCode = generateRoomCode(6);
      el("roomCodeText").textContent = roomCode;

      // Host must be inside players/ to read/write under rules
      const hostName = el("hostName").value || "HOST";
      await joinRoomAsHost(roomCode, hostName);

      const s = getSettingsFromUI();
      settings = s;

      await set(settingsRef(roomCode), {
        creatorUid,
        createdAt: nowMs(),
        ...s
      });

      await set(stateRef(roomCode), {
        phase:”waiting”,
        day: 0,
        createdAt: nowMs(),
        hostText: "Oda hazır. Oyuncuların katılması bekleniyor."
      });

      // enable buttons
      el("btnSaveSettings").disabled = false;
      el("btnStartGame").disabled = false;
      el("btnForceNight").disabled = false;
      el("btnStartVote").disabled = false;
      el("btnSkipVote").disabled = false;

      setHostText(`Oda oluşturuldu. Kod: ${roomCode}. Oyuncular katılsın.`, true);

      wireListeners();
    }

    let unsubPlayers = null, unsubState = null, unsubVoteCall = null;

    function wireListeners(){
      if (!roomCode) return;

      unsubPlayers = listen(playersRef(roomCode), (val) => {
        players = val || {};
        renderPlayers();
      });

      unsubState = listen(stateRef(roomCode), (st) => {
        setPhaseUI(st || {});
        if (st?.hostText) el("hostText").textContent = st.hostText;
      });

      unsubVoteCall = listen(voteCallRequestsRef(roomCode), (reqs) => {
        updateVoteCallUI(reqs || {});
      });
    }

    async function saveSettings(){
      if (!roomCode) return;
      const s = getSettingsFromUI();
      settings = s;
      await update(settingsRef(roomCode), s);
      setHostText("Ayarlar kaydedildi.", true);
    }

    async function dealRolesAndStart(){
      if (!roomCode) return;

      const s = await get(settingsRef(roomCode));
      settings = s.exists() ? s.val() : getSettingsFromUI();

      const alive = aliveUids(players);
      if (alive.length < 3){
        setHostText("En az 3 oyuncu gerekli.", true);
        return;
      }

      const deck = makeRoleDeck(alive, settings);

      // Write roles into secret/roles/{uid}
      const updates = {};
      alive.forEach((uid, i) => {
        updates[`rooms/${roomCode}/secret/roles/${uid}`] = {
          role: deck[i],
          // inbox: player’a gizli mesaj kanalı
          inbox: {
            t: nowMs(),
            msg: "Rolün dağıtıldı. Host başlatınca başlayacak."
          }
        };
      });

      await update(ref(window.db, "/"), updates); // uses global db from firebase.js? (safer: import db) -> we used ref from firebase.js; but window.db may not exist.
    }

    // ⚠️ Yukarıdaki tek satır "window.db" bazı kurulumlarda yoktur.
    // Bu yüzden updateRef'i direkt kullanacağız:
    async function bulkUpdate(pathMap){
      // pathMap: { "rooms/..": {...} }
      // firebase.js export etmediğimiz için ref(db, "/") kullanmalıyız
      // ama firebase.js içinde db export var. Erişelim:
      const { db } = await import("./firebase.js");
      await update(ref(db, "/"), pathMap);
    }

    async function dealRolesAndStart_SAFE(){
      if (!roomCode) return;

      const sSnap = await get(settingsRef(roomCode));
      settings = sSnap.exists() ? sSnap.val() : getSettingsFromUI();

      const alive = aliveUids(players);
      if (alive.length < 3){
        setHostText("En az 3 oyuncu gerekli.", true);
        return;
      }

      const deck = makeRoleDeck(alive, settings);

      const pathMap = {};
      alive.forEach((uid, i) => {
        pathMap[`rooms/${roomCode}/secret/roles/${uid}`] = {
          role: deck[i],
          inbox: { t: nowMs(), msg: "Rolün dağıtıldı. Oyun başlıyor." }
        };
      });

      // reset vote + night nodes
      pathMap[`rooms/${roomCode}/voting/votes`] = null;
      pathMap[`rooms/${roomCode}/day/voteCall/requests`] = null;
      pathMap[`rooms/${roomCode}/night/actions`] = null;
      pathMap[`rooms/${roomCode}/night/results`] = null;

      // state
      pathMap[`rooms/${roomCode}/state`] = {
        phase: "discussion",
        day: 1,
        startedAt: nowMs(),
        hostText: `Gün 1: Tartışma başladı. Süre: ${settings.discussionSec} sn.`,
        timerEndsAt: nowMs() + settings.discussionSec * 1000
      };

      await bulkUpdate(pathMap);

      setHostText(`Roller dağıtıldı. Gün 1 tartışma başladı.`, true);
      speakTR("Gün bir. Tartışma başladı.");
    }

    async function startNight(){
      if (!roomCode) return;
      const sSnap = await get(settingsRef(roomCode));
      settings = sSnap.exists() ? sSnap.val() : getSettingsFromUI();

      await update(stateRef(roomCode), {
        phase: "night",
        nightStage: "kill",
        hostText: "Gece oldu. Katil(ler) uyanıyor. Kurban seçin.",
        timerEndsAt: nowMs() + settings.nightSec * 1000
      });

      speakTR("Gece oldu. Katiller uyanıyor. Kurban seçin.");
    }

    async function startVote(){
      if (!roomCode) return;

      const sSnap = await get(settingsRef(roomCode));
      settings = sSnap.exists() ? sSnap.val() : getSettingsFromUI();

      // reset votes
      await set(votingVotesRef(roomCode), null);

      await update(stateRef(roomCode), {
        phase: "voting",
        hostText: `Oylama başladı. Süre: ${settings.voteSec} sn.`,
        timerEndsAt: nowMs() + settings.voteSec * 1000
      });

      speakTR("Oylama başladı.");
    }

    async function skipVote(){
      if (!roomCode) return;
      await update(stateRef(roomCode), {
        phase: "discussion",
        hostText: "Oylama yapılmadı. Tartışma devam ediyor.",
        timerEndsAt: nowMs() + (settings?.discussionSec || 120) * 1000
      });
      speakTR("Oylama yapılmadı. Tartışma devam ediyor.");
    }

    // ---- Night resolution pipeline (host-driven) ----
    async function resolveNightAndGoMorning(){
      if (!roomCode) return;

      // read actions
      const actionsSnap = await get(nightActionsRef(roomCode));
      const actions = actionsSnap.exists() ? actionsSnap.val() : {};

      // actions structure:
      // actions.kill: { uid: targetUid }
      // actions.protect: { uid: targetUid }
      // actions.investigate: { uid: targetUid }
      const killMap = actions?.kill || {};
      const protectMap = actions?.protect || {};
      const investigateMap = actions?.investigate || {};

      // determine kill target: most picked by killers, tie => no kill
      const killTally = new Map();
      for (const targetUid of Object.values(killMap)) {
        if (!targetUid) continue;
        killTally.set(targetUid, (killTally.get(targetUid) || 0) + 1);
      }
      let killTarget = null, best = 0, tie = false;
      for (const [t, c] of killTally.entries()){
        if (c > best){ best = c; killTarget = t; tie = false; }
        else if (c === best){ tie = true; }
      }
      if (tie) killTarget = null;

      // determine protected: if any doctor protected that target => saved
      const protectedTargets = new Set(Object.values(protectMap).filter(Boolean));
      const saved = killTarget && protectedTargets.has(killTarget);

      // apply death if not saved
      let deadUid = null;
      if (killTarget && !saved) {
        deadUid = killTarget;
        await update(playerRef(roomCode, deadUid), { alive: false, diedAt: nowMs() });
      }

      // detective feedback: only to detective uid(s)
      // We'll write into their secret/roles/{uid}/inbox
      const rolesSnap = await get(ref(await import("./firebase.js").then(m=>m.db), `rooms/${roomCode}/secret/roles`));
      // above is messy; keep it simple: we won't fetch rolesSnap here; we already have roles in DB, but host may not.
      // We'll derive detective uids by scanning secret/roles via read:
      // Actually: easier -> ask players to show result? No. We'll do proper read:
      const { db } = await import("./firebase.js");
      const secretRolesSnap = await get(ref(db, `rooms/${roomCode}/secret/roles`));
      const secretRoles = secretRolesSnap.exists() ? secretRolesSnap.val() : {};
      rolesByUid = secretRoles || {};

      // investigation results
      for (const [detUid, targetUid] of Object.entries(investigateMap || {})) {
        if (!targetUid) continue;
        const targetRole = secretRoles?.[targetUid]?.role || "UNKNOWN";
        const msg = `${(players?.[targetUid]?.name || "Oyuncu")} rolü: ${ROLE_LABEL_TR[targetRole] || targetRole}`;
        await update(myRoleRef(roomCode, detUid), { inbox: { t: nowMs(), msg } });
      }

      // doctor self-protect limit tracking (1 time)
      // if a doctor protected themselves, increment doctorSelfProtectUsed (host can write due to rules patch!)
      for (const [docUid, targetUid] of Object.entries(protectMap || {})) {
        if (docUid === targetUid && targetUid) {
          const used = Number(players?.[docUid]?.doctorSelfProtectUsed || 0);
          if (used < 1) {
            await update(playerRef(roomCode, docUid), { doctorSelfProtectUsed: used + 1 });
          }
        }
      }

      // write night results (public-ish but without role reveal)
      const deadName = deadUid ? (players?.[deadUid]?.name || "Bir oyuncu") : null;
      let morningText = "Sabah oldu. Bu gece kimse ölmedi.";
      if (deadUid) morningText = `Sabah oldu. Dün gece ${deadName} ölü bulundu.`;

      await set(nightResultsRef(roomCode), {
        t: nowMs(),
        deadUid: deadUid || null,
        deadName: deadName || null,
        saved: !!saved,
        killAttempted: !!killTarget
      });

      // win check (rolesByUid + players)
      const win = computeWin(players, secretRoles);
      if (win.ended) {
        const winnerText = win.winner === "TOWN"
          ? "Oyun bitti. Vatandaşlar kazandı. Katiller yakalandı."
          : "Oyun bitti. Katiller kazandı. Şehir düştü.";
        await update(stateRef(roomCode), {
          phase: "ended",
          hostText: winnerText,
          timerEndsAt: null,
          revealAtEnd: true
        });
        speakTR(winnerText);
        return;
      }

      // continue: discussion (NO ROLE REVEAL)
      await update(stateRef(roomCode), {
        phase: "discussion",
        hostText: morningText + " Tartışma başladı.",
        day: (Number((await get(stateRef(roomCode))).val()?.day || 1)),
        timerEndsAt: nowMs() + (settings?.discussionSec || 120) * 1000
      });

      speakTR(morningText);
    }

    // ---- Voting resolution ----
    async function resolveVote(){
      if (!roomCode) return;

      const votesSnap = await get(votingVotesRef(roomCode));
      const votes = votesSnap.exists() ? votesSnap.val() : {};

      const { best, bestCount, tie } = pickMostVoted(votes);
      const alive = aliveUids(players);
      const maj = strictMajority(alive.length);

      // skip/none or tie or no majority => no elimination
      if (!best || tie || best === "SKIP" || bestCount < maj) {
        const txt = "Oylama sonucu: Kimse elenmedi. Tartışma devam ediyor.";
        await update(stateRef(roomCode), {
          phase: "discussion",
          hostText: txt,
          timerEndsAt: nowMs() + (settings?.discussionSec || 120) * 1000
        });
        speakTR(txt);
        return;
      }

      // eliminate best uid (no role reveal unless game ends)
      const name = players?.[best]?.name || "Oyuncu";
      await update(playerRef(roomCode, best), { alive: false, eliminatedAt: nowMs() });

      // win check after elimination
      const { db } = await import("./firebase.js");
      const secretRolesSnap = await get(ref(db, `rooms/${roomCode}/secret/roles`));
      const secretRoles = secretRolesSnap.exists() ? secretRolesSnap.val() : {};

      const win = computeWin(players, secretRoles);
      if (win.ended) {
        const winnerText = win.winner === "TOWN"
          ? "Oyun bitti. Vatandaşlar kazandı."
          : "Oyun bitti. Katiller kazandı.";
        await update(stateRef(roomCode), {
          phase: "ended",
          hostText: `${name} elendi. ${winnerText}`,
          timerEndsAt: null,
          revealAtEnd: true
        });
        speakTR(`${name} elendi. ${winnerText}`);
        return;
      }

      const txt = `${name} elendi. (Rol açıklanmadı.) Tartışma devam ediyor.`;
      await update(stateRef(roomCode), {
        phase: "discussion",
        hostText: txt,
        timerEndsAt: nowMs() + (settings?.discussionSec || 120) * 1000
      });
      speakTR(`${name} elendi. Tartışma devam ediyor.`);
    }

    // ---- Buttons ----
    el("btnCreateRoom").addEventListener("click", createRoom);
    el("btnSaveSettings").addEventListener("click", saveSettings);
    el("btnStartGame").addEventListener("click", dealRolesAndStart_SAFE);
    el("btnForceNight").addEventListener("click", startNight);
    el("btnStartVote").addEventListener("click", startVote);
    el("btnSkipVote").addEventListener("click", skipVote);

    // Host “resolve” butonlarını şimdilik klavyeyle tetikle (hızlı debug):
    // N: night resolve, V: vote resolve
    window.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === "n") resolveNightAndGoMorning();
      if (e.key.toLowerCase() === "v") resolveVote();
    });

    // bootstrap auth
    ensureAuth().then(() => setHostText("Giriş hazır. Oda oluştur.", false));
  </script>
</body>
</html>
