<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Shadow City — Host</title>
  <link rel="stylesheet" href="./styles.css"/>
</head>
<body>
  <div class="shell">
    <header class="topbar">
      <div class="brand">
        <div class="brand__title">SHADOW CITY — HOST</div>
        <div class="brand__subtitle">Moderatör ekranı (TV/PC)</div>
      </div>
      <a class="pill" href="./index.html">↩ Ana Menü</a>
    </header>

    <main class="grid2">
      <!-- Left: Setup -->
      <section class="card stack">
        <h2 class="h2">Oda</h2>

        <div class="notice">
          <div class="muted tiny">Oda Kodu</div>
          <div class="big" id="roomCodeText">—</div>
          <div class="tiny muted">Oyuncular şu adresten girsin: <strong>/player.html</strong></div>
        </div>

        <div class="row">
          <div>
            <label>Host adı (opsiyonel)</label>
            <input id="hostName" placeholder="HOST" value="HOST"/>
          </div>
          <div>
            <label>Oda oluştur</label>
            <button class="btn btn-primary" id="btnCreateRoom">ODA OLUŞTUR</button>
          </div>
        </div>

        <div class="hr"></div>

        <h2 class="h2">Oyun Ayarları</h2>

        <div class="row">
          <div>
            <label>Katil sayısı</label>
            <select id="killerCount">
              <option value="1">1</option>
              <option value="2">2</option>
            </select>
          </div>
          <div>
            <label>Dedektif</label>
            <select id="includeDetective">
              <option value="true">Var</option>
              <option value="false">Yok</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Doktor</label>
            <select id="includeDoctor">
              <option value="true">Var</option>
              <option value="false">Yok</option>
            </select>
          </div>
          <div>
            <label>Tartışma süresi (sn)</label>
            <input id="discussionSec" value="120" />
          </div>
        </div>

        <div class="row">
          <div>
            <label>Gece aksiyon süresi (sn)</label>
            <input id="nightSec" value="45" />
          </div>
          <div>
            <label>Oylama süresi (sn)</label>
            <input id="voteSec" value="45" />
          </div>
        </div>

        <div class="row">
          <div>
            <label>Katil “Kimseyi öldürme” seçeneği</label>
            <select id="allowNoKill">
              <option value="true">Açık</option>
              <option value="false">Kapalı</option>
            </select>
          </div>
          <div>
            <label>Oyun bitmeden ölenin rolü açıklansın mı?</label>
            <select id="revealDeadRoleDuringGame">
              <option value="false" selected>Hayır (önerilen)</option>
              <option value="true">Evet</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Doktor kendini koruma hakkı</label>
            <select id="doctorSelfSaveMax">
              <option value="0">0</option>
              <option value="1" selected>1</option>
              <option value="2">2</option>
            </select>
          </div>
          <div>
            <label class="muted">İpucu</label>
            <div class="tiny muted">0: hiç koruyamaz • 1: bir kez korur (senin kuralın)</div>
          </div>
        </div>

        <button class="btn btn-ghost" id="btnSaveSettings" disabled>AYARLARI KAYDET</button>

        <div class="hr"></div>

        <h2 class="h2">Kontroller</h2>
        <div class="grid2">
          <button class="btn btn-primary" id="btnStartGame" disabled>ROL DAĞIT & BAŞLAT</button>
          <button class="btn btn-danger" id="btnForceNight" disabled>GECEYİ BAŞLAT</button>
        </div>

        <div class="grid2">
          <button class="btn btn-ghost" id="btnStartVote" disabled>OYLAMA BAŞLAT (OPS.)</button>
          <button class="btn btn-ghost" id="btnSkipVote" disabled>OYLAMAYI ATLA</button>
        </div>

        <div class="grid2">
          <button class="btn btn-primary" id="btnResolveNight" disabled>GECEYİ SONUÇLANDIR</button>
          <button class="btn btn-primary" id="btnResolveVote" disabled>OYLAMAYI SONUÇLANDIR</button>
        </div>

        <div class="hr"></div>

        <div class="notice" id="hostNarration">
          <strong>Anons:</strong>
          <div class="muted" id="hostText">Oda oluşturulmadı.</div>
        </div>
      </section>

      <!-- Right: Players + status -->
      <section class="card stack">
        <h2 class="h2">Durum</h2>

        <div class="kpi">
          <div class="box">
            <div class="num" id="kpiAlive">0</div>
            <div class="lbl">Hayatta</div>
          </div>
          <div class="box">
            <div class="num" id="kpiDead">0</div>
            <div class="lbl">Elendi</div>
          </div>
          <div class="box">
            <div class="num" id="kpiPhase">—</div>
            <div class="lbl">Faz</div>
          </div>
          <div class="box">
            <div class="num" id="kpiDay">—</div>
            <div class="lbl">Gün</div>
          </div>
        </div>

        <h2 class="h2">Oyuncular</h2>
        <div class="list" id="playersList"></div>

        <div class="hr"></div>

        <h2 class="h2">Oylama Çağrıları</h2>
        <div class="notice">
          <div class="muted tiny">Oyuncular “Oylama istiyorum” gönderebilir. Çoğunluk olursa başlatmayı tercih edebilirsin.</div>
          <div class="row" style="margin-top:10px">
            <div class="pill" id="voteCallCount">0 istek</div>
            <div class="pill" id="voteCallMajority">— / —</div>
          </div>
        </div>

      </section>
    </main>
  </div>

  <script type="module">
    import {
      ensureAuth,
      generateRoomCode,
      joinRoomAsHost,
      settingsRef,
      stateRef,
      playersRef,
      playerRef,
      myRoleRef,
      voteCallRequestsRef,
      votingVotesRef,
      nightActionsRef,
      nightResultsRef,
      listen,
      set,
      update,
      get,
      ref,
      db
    } from "./firebase.js";

    import {
      ROLES,
      ROLE_LABEL_TR,
      ACTIONS,
      speakTR,
      clampInt,
      makeRoleDeck,
      aliveUids,
      computeWin,
      strictMajority,
      pickMostVoted,
      nowMs,
      mergeSettings,
      resolveNight
    } from "./shared.js";

    let roomCode = null;
    let creatorUid = null;

    let players = {};       // players/{uid}
    let rolesByUid = {};    // secret/roles snapshot (host reads when needed)
    let settings = null;    // merged settings cache
    let stateCache = null;

    const el = (id) => document.getElementById(id);

    function escapeHtml(s){
      return String(s || "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#39;");
    }

    function setHostText(text, speak = false){
      el("hostText").textContent = text;
      if (speak) speakTR(text);
    }

    function getSettingsFromUI(){
      return mergeSettings({
        killerCount: clampInt(el("killerCount").value, 1, 6, 1),
        includeDetective: el("includeDetective").value === "true",
        includeDoctor: el("includeDoctor").value === "true",

        discussionSec: clampInt(el("discussionSec").value, 15, 9999, 120),
        nightSec: clampInt(el("nightSec").value, 10, 9999, 45),
        voteSec: clampInt(el("voteSec").value, 10, 9999, 45),

        allowNoKill: el("allowNoKill").value === "true",
        revealDeadRoleDuringGame: el("revealDeadRoleDuringGame").value === "true",
        doctorSelfSaveMax: clampInt(el("doctorSelfSaveMax").value, 0, 9, 1),
      });
    }

    function setPhaseUI(st){
      el("kpiPhase").textContent = st?.phase || "—";
      el("kpiDay").textContent = st?.day ? String(st.day) : "—";
    }

    function renderPlayers(){
      const list = el("playersList");
      const entries = Object.entries(players || {}).filter(([,p]) => p && !p.isHost);

      let alive = 0, dead = 0;
      const rows = entries.map(([uid, p]) => {
        if (p.alive) alive++; else dead++;
        return `
          <div class="item">
            <div>
              <div><strong>${escapeHtml(p.name || "Player")}</strong></div>
              <div class="tiny muted">${uid.slice(0,6)}…</div>
              ${p.alive ? "" : `<div class="tiny muted">⛔ Elendi</div>`}
            </div>
            <div class="badge ${p.alive ? "badge--alive":"badge--dead"}">
              ${p.alive ? "Alive" : "Dead"}
            </div>
          </div>
        `;
      }).join("");

      list.innerHTML = rows || `<div class="item"><div class="muted">Henüz oyuncu yok.</div></div>`;

      el("kpiAlive").textContent = String(alive);
      el("kpiDead").textContent = String(dead);
    }

    function updateVoteCallUI(voteCallRequests){
      const aliveCount = aliveUids(players).length;
      const maj = strictMajority(aliveCount);
      const reqCount = Object.keys(voteCallRequests || {}).length;

      el("voteCallCount").textContent = `${reqCount} istek`;
      el("voteCallMajority").textContent = `${reqCount} / ${maj} çoğunluk`;
    }

    async function readSettings(){
      if (!roomCode) return getSettingsFromUI();
      const sSnap = await get(settingsRef(roomCode));
      return mergeSettings(sSnap.exists() ? sSnap.val() : getSettingsFromUI());
    }

    async function readSecretRoles(){
      if (!roomCode) return {};
      const snap = await get(ref(db, `rooms/${roomCode}/secret/roles`));
      return snap.exists() ? (snap.val() || {}) : {};
    }

    async function createRoom(){
      const auth = await ensureAuth();
      creatorUid = auth.uid;

      roomCode = generateRoomCode(6);
      el("roomCodeText").textContent = roomCode;

      const hostName = el("hostName").value || "HOST";
      await joinRoomAsHost(roomCode, hostName);

      settings = getSettingsFromUI();

      await set(settingsRef(roomCode), {
        creatorUid,
        createdAt: nowMs(),
        ...settings
      });

      await set(stateRef(roomCode), {
        phase: "waiting",
        day: 0,
        createdAt: nowMs(),
        hostText: "Oda hazır. Oyuncuların katılması bekleniyor.",
        timerEndsAt: null
      });

      // enable buttons
      el("btnSaveSettings").disabled = false;
      el("btnStartGame").disabled = false;
      el("btnForceNight").disabled = false;
      el("btnStartVote").disabled = false;
      el("btnSkipVote").disabled = false;
      el("btnResolveNight").disabled = false;
      el("btnResolveVote").disabled = false;

      setHostText(`Oda oluşturuldu. Kod: ${roomCode}. Oyuncular katılsın.`, true);
      wireListeners();
    }

    let unsubPlayers = null, unsubState = null, unsubVoteCall = null;

    function wireListeners(){
      if (!roomCode) return;

      if (unsubPlayers) unsubPlayers();
      if (unsubState) unsubState();
      if (unsubVoteCall) unsubVoteCall();

      unsubPlayers = listen(playersRef(roomCode), (val) => {
        players = val || {};
        renderPlayers();
      });

      unsubState = listen(stateRef(roomCode), (st) => {
        stateCache = st || {};
        setPhaseUI(stateCache);
        if (stateCache?.hostText) el("hostText").textContent = stateCache.hostText;
      });

      unsubVoteCall = listen(voteCallRequestsRef(roomCode), (reqs) => {
        updateVoteCallUI(reqs || {});
      });
    }

    async function saveSettings(){
      if (!roomCode) return;
      settings = getSettingsFromUI();
      await update(settingsRef(roomCode), settings);
      setHostText("Ayarlar kaydedildi.", true);
    }

    async function bulkUpdate(pathMap){
      await update(ref(db, "/"), pathMap);
    }

    async function dealRolesAndStart(){
      if (!roomCode) return;

      settings = await readSettings();

      const alive = aliveUids(players); // host hariç alive
      if (alive.length < 3){
        setHostText("En az 3 oyuncu gerekli.", true);
        return;
      }

      // Roller dağıt
      const deck = makeRoleDeck(alive, settings);

      const pathMap = {};

      // oyuncu state reset (alive=true, selfSaveUsed=0) + gizli roller
      alive.forEach((uid, i) => {
        pathMap[`rooms/${roomCode}/players/${uid}/alive`] = true;
        pathMap[`rooms/${roomCode}/players/${uid}/doctorSelfProtectUsed`] = 0;

        pathMap[`rooms/${roomCode}/secret/roles/${uid}`] = {
          role: deck[i],
          inbox: { t: nowMs(), msg: "Rolün dağıtıldı. Oyun başlıyor." }
        };
      });

      // reset nodes
      pathMap[`rooms/${roomCode}/voting/votes`] = null;
      pathMap[`rooms/${roomCode}/voting/result`] = null;
      pathMap[`rooms/${roomCode}/day/voteCall/requests`] = null;
      pathMap[`rooms/${roomCode}/night/actions`] = null;
      pathMap[`rooms/${roomCode}/night/results`] = null;

      // state -> discussion day 1
      pathMap[`rooms/${roomCode}/state`] = {
        phase: "discussion",
        day: 1,
        startedAt: nowMs(),
        hostText: `Gün 1: Tartışma başladı. Süre: ${settings.discussionSec} sn.`,
        timerEndsAt: nowMs() + settings.discussionSec * 1000
      };

      await bulkUpdate(pathMap);

      setHostText("Roller dağıtıldı. Gün 1 tartışma başladı.", true);
      speakTR("Gün bir. Tartışma başladı.");
    }

    async function startNight(){
      if (!roomCode) return;

      settings = await readSettings();

      // night/actions resetle (önceki tur kalıntısı olmasın)
      await set(nightActionsRef(roomCode), null);

      await update(stateRef(roomCode), {
        phase: "night",
        hostText: "Gece oldu. Katil(ler) uyanıyor. Kurban seçin.",
        timerEndsAt: nowMs() + settings.nightSec * 1000
      });

      // TTS script: katil -> doktor -> dedektif
      speakTR("Gece oldu. Katiller uyanıyor. Kurban seçin.");
    }

    async function startVote(){
      if (!roomCode) return;
      settings = await readSettings();

      await set(votingVotesRef(roomCode), null);

      await update(stateRef(roomCode), {
        phase: "voting",
        hostText: `Oylama başladı. Süre: ${settings.voteSec} sn.`,
        timerEndsAt: nowMs() + settings.voteSec * 1000
      });

      speakTR("Oylama başladı.");
    }

    async function skipVote(){
      if (!roomCode) return;
      settings = await readSettings();

      await update(stateRef(roomCode), {
        phase: "discussion",
        hostText: "Oylama yapılmadı. Tartışma devam ediyor.",
        timerEndsAt: nowMs() + settings.discussionSec * 1000
      });

      speakTR("Oylama yapılmadı. Tartışma devam ediyor.");
    }

    // ---- Night resolution (host) ----
    async function resolveNightAndGoMorning(){
      if (!roomCode) return;

      settings = await readSettings();

      // Actions
      const actionsSnap = await get(nightActionsRef(roomCode));
      const actions = actionsSnap.exists() ? actionsSnap.val() : {};

      // Beklenen yapı:
      // night/actions/kill/{killerUid}: targetUid | "NO_KILL"
      // night/actions/protect/{doctorUid}: targetUid
      // night/actions/investigate/{detectiveUid}: targetUid
      const killMap = actions?.kill || {};
      const protectMap = actions?.protect || {};
      const investigateMap = actions?.investigate || {};

      // killers: en çok oy alan hedef; tie -> NO_KILL (veya null)
      const tally = new Map();
      for (const target of Object.values(killMap)) {
        if (!target) continue;
        if (target === ACTIONS.NO_KILL) continue; // NO_KILL tally etmeyelim
        tally.set(target, (tally.get(target) || 0) + 1);
      }

      let killTargetUid = null;
      let best = 0;
      let tie = false;
      for (const [t, c] of tally.entries()){
        if (c > best){ best = c; killTargetUid = t; tie = false; }
        else if (c === best){ tie = true; }
      }

      // tie varsa ve allowNoKill açıksa -> NO_KILL gibi davranalım
      if (tie) killTargetUid = (settings.allowNoKill ? ACTIONS.NO_KILL : null);

      // Doktor hedefi (tek doktor varsayıyoruz; birden fazla olursa ilk geçerli)
      let doctorUid = null;
      let doctorSaveUid = null;
      for (const [uid, t] of Object.entries(protectMap || {})) {
        if (!t) continue;
        doctorUid = uid;
        doctorSaveUid = t;
        break;
      }

      // Doktor self-save limiti: oyuncu kaydındaki doctorSelfProtectUsed üzerinden kontrol
      const doctorState = doctorUid ? { selfSaveUsed: Number(players?.[doctorUid]?.doctorSelfProtectUsed || 0) } : { selfSaveUsed: 0 };

      const nightRes = resolveNight({
        killerChoiceUid: killTargetUid,
        doctorSaveUid,
        doctorUid,
        playersObj: players,
        doctorState,
        settings
      });

      // Self-save kullanıldıysa host oyuncu kaydını artır
      if (nightRes.reason === "DOCTOR_SELF_SAVE" && doctorUid) {
        const used = Number(players?.[doctorUid]?.doctorSelfProtectUsed || 0);
        await update(playerRef(roomCode, doctorUid), { doctorSelfProtectUsed: used + 1 });
      }

      // Ölüm uygula
      let deadUid = null;
      if (nightRes.diedUid) {
        deadUid = nightRes.diedUid;
        await update(playerRef(roomCode, deadUid), { alive: false, diedAt: nowMs() });
      }

      // Dedektif raporu: inbox’a yaz (her dedektif kendi sonucunu görür)
      const secretRoles = await readSecretRoles();
      rolesByUid = secretRoles || {};

      for (const [detUid, targetUid] of Object.entries(investigateMap || {})) {
        if (!targetUid) continue;
        const targetRole = secretRoles?.[targetUid]?.role || "UNKNOWN";
        const msg = `${(players?.[targetUid]?.name || "Oyuncu")} rolü: ${ROLE_LABEL_TR[targetRole] || targetRole}`;
        await update(myRoleRef(roomCode, detUid), { inbox: { t: nowMs(), msg } });
      }

      // Night results (public-ish, role reveal yok)
      const deadName = deadUid ? (players?.[deadUid]?.name || "Bir oyuncu") : null;

      let morningText = "Sabah oldu. Bu gece kimse ölmedi.";
      if (deadUid) morningText = `Sabah oldu. Dün gece ${deadName} ölü bulundu.`;

      await set(nightResultsRef(roomCode), {
        t: nowMs(),
        deadUid: deadUid || null,
        deadName: deadName || null,
        saved: !!nightRes.saved,
        killAttempted: !!killTargetUid,
        reason: nightRes.reason
      });

      // Win check için güncel players snapshot al (stale olmasın)
      const playersSnap = await get(playersRef(roomCode));
      const freshPlayers = playersSnap.exists() ? playersSnap.val() : players;

      const win = computeWin(freshPlayers, secretRoles);
      if (win.ended) {
        const winnerText = win.winner === "TOWN"
          ? "Oyun bitti. Vatandaşlar kazandı. Katiller yakalandı."
          : "Oyun bitti. Katiller kazandı. Şehir düştü.";

        await update(stateRef(roomCode), {
          phase: "ended",
          hostText: winnerText,
          timerEndsAt: null,
          revealAtEnd: true
        });

        speakTR(winnerText);
        return;
      }

      // Tartışmaya dön — day aynı kalır (gün, gece sabah aynı gün döngüsü)
      await update(stateRef(roomCode), {
        phase: "discussion",
        hostText: morningText + " Tartışma başladı.",
        timerEndsAt: nowMs() + settings.discussionSec * 1000
      });

      speakTR(morningText);
    }

    // ---- Voting resolution (host) ----
    async function resolveVote(){
      if (!roomCode) return;
      settings = await readSettings();

      const votesSnap = await get(votingVotesRef(roomCode));
      const votes = votesSnap.exists() ? votesSnap.val() : {};

      const { best, bestCount, tie } = pickMostVoted(votes);

      const alive = aliveUids(players);
      const maj = strictMajority(alive.length);

      // tie / SKIP / majority yok => kimse elenmez
      if (!best || tie || best === ACTIONS.SKIP_VOTE || bestCount < maj) {
        const txt = "Oylama sonucu: Kimse elenmedi. Tartışma devam ediyor.";
        await update(stateRef(roomCode), {
          phase: "discussion",
          hostText: txt,
          timerEndsAt: nowMs() + settings.discussionSec * 1000
        });
        speakTR(txt);
        return;
      }

      // eleme
      const name = players?.[best]?.name || "Oyuncu";
      await update(playerRef(roomCode, best), { alive: false, eliminatedAt: nowMs() });

      // win check için güncel snapshotlar
      const [playersSnap, secretRolesSnap] = await Promise.all([
        get(playersRef(roomCode)),
        get(ref(db, `rooms/${roomCode}/secret/roles`))
      ]);

      const freshPlayers = playersSnap.exists() ? playersSnap.val() : players;
      const secretRoles = secretRolesSnap.exists() ? secretRolesSnap.val() : {};

      const win = computeWin(freshPlayers, secretRoles);

      if (win.ended) {
        const winnerText = win.winner === "TOWN"
          ? "Oyun bitti. Vatandaşlar kazandı."
          : "Oyun bitti. Katiller kazandı.";

        const full = `${name} elendi. ${winnerText}`;

        await update(stateRef(roomCode), {
          phase: "ended",
          hostText: full,
          timerEndsAt: null,
          revealAtEnd: true
        });

        speakTR(full);
        return;
      }

      const txt = `${name} elendi. (Rol açıklanmadı.) Tartışma devam ediyor.`;
      await update(stateRef(roomCode), {
        phase: "discussion",
        hostText: txt,
        timerEndsAt: nowMs() + settings.discussionSec * 1000
      });
      speakTR(`${name} elendi. Tartışma devam ediyor.`);
    }

    // ---- Buttons ----
    el("btnCreateRoom").addEventListener("click", createRoom);
    el("btnSaveSettings").addEventListener("click", saveSettings);
    el("btnStartGame").addEventListener("click", dealRolesAndStart);
    el("btnForceNight").addEventListener("click", startNight);
    el("btnStartVote").addEventListener("click", startVote);
    el("btnSkipVote").addEventListener("click", skipVote);
    el("btnResolveNight").addEventListener("click", resolveNightAndGoMorning);
    el("btnResolveVote").addEventListener("click", resolveVote);

    // Keyboard shortcuts (opsiyonel ama güzel)
    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "n") resolveNightAndGoMorning();
      if (k === "v") resolveVote();
      if (k === "g") startNight();
    });

    // bootstrap auth
    ensureAuth().then(() => setHostText("Giriş hazır. Oda oluştur.", false));
  </script>
</body>
</html>
