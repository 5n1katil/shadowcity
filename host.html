<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Shadow City ‚Äî Host</title>
  <style>
    body{margin:0;font-family:system-ui,Segoe UI,Arial;background:#0b0d14;color:#e9ecff}
    .wrap{max-width:1100px;margin:0 auto;padding:18px}
    .top{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .card{background:#12172a;border:1px solid #2a3358;border-radius:14px;padding:16px}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .btn{padding:12px 14px;border-radius:12px;border:1px solid #33406b;background:#192041;color:#e9ecff;cursor:pointer}
    .btn:hover{filter:brightness(1.08)}
    .btn.primary{background:#2a57ff;border-color:#2a57ff}
    .pill{padding:8px 10px;border:1px solid #2a3358;border-radius:999px;background:#0e1324}
    .muted{opacity:.75}
    .timer{font-size:72px;font-weight:800;letter-spacing:.06em}
    .big{font-size:28px;font-weight:700}
    input,select{padding:10px;border-radius:10px;border:1px solid #2a3358;background:#0e1324;color:#e9ecff}
    label{font-size:12px;opacity:.8}
    .grid{display:grid;grid-template-columns: 1fr 1fr; gap:12px}
    @media(max-width:900px){.grid{grid-template-columns:1fr}}
    .list{display:flex;flex-direction:column;gap:8px}
    .item{display:flex;justify-content:space-between;gap:10px;padding:10px;border:1px solid #2a3358;border-radius:12px;background:#0e1324}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>
        <div class="big">SHADOW CITY ‚Äî HOST</div>
        <div class="muted">Otomatik akƒ±≈ü ‚Ä¢ TV/PC</div>
      </div>
      <div class="row">
        <a class="pill" href="./index.html" style="color:#e9ecff;text-decoration:none">‚Ü© Men√º</a>
      </div>
    </div>

    <div style="height:12px"></div>

    <div class="grid">
      <div class="card">
        <div class="row" style="align-items:flex-end">
          <div style="flex:1">
            <label>Host adƒ±</label><br/>
            <input id="hostName" value="HOST"/>
          </div>
          <button class="btn primary" id="btnCreate">Oda Olu≈ütur</button>
          <button class="btn" id="btnStart" disabled>Oyunu Ba≈ülat</button>
        </div>

        <div style="height:12px"></div>
        <div class="row">
          <div class="pill">Oda Kodu: <strong id="roomCode">‚Äî</strong></div>
          <div class="pill">Faz: <strong id="phase">‚Äî</strong></div>
          <div class="pill">G√ºn: <strong id="day">‚Äî</strong></div>
        </div>

        <div style="height:14px"></div>
        <div class="timer" id="timer">--:--</div>
        <div class="muted" id="hostText">Oda olu≈ütur.</div>

        <div style="height:14px"></div>
        <div class="row">
          <div>
            <label>Tartƒ±≈üma (sn)</label><br/>
            <input id="discussionSec" value="300"/>
          </div>
          <div>
            <label>Oylama (sn)</label><br/>
            <input id="voteSec" value="45"/>
          </div>
          <div>
            <label>Gece rol s√ºresi (sn)</label><br/>
            <input id="nightSec" value="35"/>
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="row">
          <div>
            <label>Katil sayƒ±sƒ±</label><br/>
            <select id="killerCount">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
            </select>
          </div>
          <div>
            <label>Doktor</label><br/>
            <select id="includeDoctor">
              <option value="true" selected>Var</option>
              <option value="false">Yok</option>
            </select>
          </div>
          <div>
            <label>Dedektif</label><br/>
            <select id="includeDetective">
              <option value="true" selected>Var</option>
              <option value="false">Yok</option>
            </select>
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="row">
          <div>
            <label>Katil ‚ÄúNO KILL‚Äù</label><br/>
            <select id="allowNoKill">
              <option value="true" selected>A√ßƒ±k</option>
              <option value="false">Kapalƒ±</option>
            </select>
          </div>
          <div>
            <label>Doktor self-protect</label><br/>
            <select id="doctorSelfSaveMax">
              <option value="0">0</option>
              <option value="1" selected>1</option>
            </select>
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="muted" style="font-size:12px">
          Oyun ba≈üladƒ±ktan sonra buraya dokunmana gerek yok. TV konu≈üur, fazlar otomatik akar.
        </div>
      </div>

      <div class="card">
        <div class="big">Oyuncular</div>
        <div class="muted" style="margin:6px 0 10px 0">Telefon: <strong>/player.html</strong></div>
        <div class="list" id="playersList"></div>
      </div>
    </div>
  </div>

  <script type="module">
    import {
      ensureAuth, generateRoomCode, joinRoomAsHost,
      settingsRef, stateRef, playersRef, playerRef, secretRoleRef,
      requestsVoteRef, requestsFastNightRef,
      votingVotesRef,
      nightActionsKillRef, nightActionsProtectRef, nightActionsInvestigateRef,
      ref, get, set, update, listen, db
    } from "./firebase.js";

    import {
      ROLES, ROLE_TR, ACTIONS, PHASE,
      clampInt, nowMs, speakTR,
      aliveUids, strictMajority, makeRoleDeck,
      pickMostVoted, resolveNight, computeWin
    } from "./shared.js";

    const el = (id)=>document.getElementById(id);

    let roomCode = null;
    let players = {};
    let settings = null;
    let state = null;
    let tickHandle = null;
    let lastSpokenMark = new Set(); // timer konu≈üma tekrarƒ±nƒ± engelle

    function uiText(t, speak=false){
      el("hostText").textContent = t;
      if (speak) speakTR(t);
      // DB'ye de yazalƒ±m (player'lar g√∂rs√ºn)
      if (roomCode) update(stateRef(roomCode), { hostText: t }).catch(()=>{});
    }

    function fmt(ms){
      if (!ms || ms<0) ms = 0;
      const s = Math.floor(ms/1000);
      const m = Math.floor(s/60);
      const r = s%60;
      return String(m).padStart(2,"0")+":"+String(r).padStart(2,"0");
    }

    function readSettingsUI(){
      return {
        discussionSec: clampInt(el("discussionSec").value, 30, 3600, 300),
        voteSec: clampInt(el("voteSec").value, 10, 600, 45),
        nightSec: clampInt(el("nightSec").value, 10, 600, 35),

        killerCount: clampInt(el("killerCount").value, 1, 6, 1),
        includeDoctor: el("includeDoctor").value === "true",
        includeDetective: el("includeDetective").value === "true",

        allowNoKill: el("allowNoKill").value === "true",
        doctorSelfSaveMax: clampInt(el("doctorSelfSaveMax").value, 0, 2, 1),

        // oyun bitmeden rol a√ßƒ±klama yok (sabit)
        revealDeadRoleDuringGame: false,
      };
    }

    async function createRoom(){
      await ensureAuth();
      roomCode = generateRoomCode(6);
      el("roomCode").textContent = roomCode;

      const hostName = el("hostName").value || "HOST";
      const me = await joinRoomAsHost(roomCode, hostName);

      settings = readSettingsUI();
      await set(settingsRef(roomCode), {
        creatorUid: me.uid,
        createdAt: nowMs(),
        ...settings
      });

      await set(stateRef(roomCode), {
        phase: PHASE.WAITING,
        day: 0,
        hostText: "Oyuncularƒ±n katƒ±lmasƒ±nƒ± bekliyoruz.",
        endsAt: null,
        awakeRole: null
      });

      // reset nodes
      await set(ref(db, `rooms/${roomCode}/requests`), null);
      await set(ref(db, `rooms/${roomCode}/voting`), null);
      await set(ref(db, `rooms/${roomCode}/night`), null);
      await set(ref(db, `rooms/${roomCode}/secret/roles`), null);

      el("btnStart").disabled = false;
      uiText(`Oda hazƒ±r. Kod: ${roomCode}. Oyuncular /player.html'den girsin.`, true);

      // listeners
      listen(playersRef(roomCode), (v)=>{ players = v||{}; renderPlayers(); });
      listen(stateRef(roomCode), (v)=>{ state = v||{}; el("phase").textContent = state.phase||"‚Äî"; el("day").textContent = state.day ?? "‚Äî"; });
    }

    function renderPlayers(){
      const list = el("playersList");
      const entries = Object.entries(players||{}).filter(([,p])=>p && !p.isHost);
      if (!entries.length){
        list.innerHTML = `<div class="item"><div class="muted">Hen√ºz oyuncu yok.</div></div>`;
        return;
      }
      list.innerHTML = entries.map(([uid,p])=>{
        const st = p.alive ? "üü¢" : "‚ö´";
        return `<div class="item">
          <div><strong>${escapeHtml(p.name||"Oyuncu")}</strong><div class="muted" style="font-size:12px">${uid.slice(0,6)}‚Ä¶</div></div>
          <div>${st}</div>
        </div>`;
      }).join("");
    }

    function escapeHtml(s){
      return String(s||"")
        .replaceAll("&","&amp;").replaceAll("<","&lt;")
        .replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#39;");
    }

    async function startGameOnce(){
      if (!roomCode) return;

      settings = readSettingsUI();
      await update(settingsRef(roomCode), settings);

      const alive = aliveUids(players);
      if (alive.length < 3){
        uiText("En az 3 oyuncu olmalƒ±.", true);
        return;
      }

      // roles daƒüƒ±t
      const deck = makeRoleDeck(alive, settings);
      const batch = {};

      // oyuncularƒ± resetle
      for (const uid of alive){
        batch[`rooms/${roomCode}/players/${uid}/alive`] = true;
        batch[`rooms/${roomCode}/players/${uid}/doctorSelfProtectUsed`] = 0;
      }
      // secret roles
      alive.forEach((uid,i)=>{
        batch[`rooms/${roomCode}/secret/roles/${uid}`] = {
          role: deck[i],
          inbox: { t: nowMs(), msg: "Rol√ºn daƒüƒ±tƒ±ldƒ±. Oyunu takip et." }
        };
      });

      // reset gameplay nodes
      batch[`rooms/${roomCode}/requests`] = null;
      batch[`rooms/${roomCode}/voting`] = null;
      batch[`rooms/${roomCode}/night`] = null;

      await update(ref(db,"/"), batch);

      // discussion day1
      await enterPhase(PHASE.DISCUSSION, settings.discussionSec, {
        day: 1,
        awakeRole: null,
        hostText: `G√ºn 1 ba≈üladƒ±. Tartƒ±≈üma zamanƒ±. (${settings.discussionSec} sn)`
      });

      uiText("G√ºn bir. Tartƒ±≈üma ba≈üladƒ±.", true);

      // otomatik tick loop ba≈ülat
      startTickLoop();
      el("btnStart").disabled = true;
      el("btnCreate").disabled = true;
    }

    async function enterPhase(phase, durationSec, extra={}){
      const endsAt = durationSec ? (nowMs() + durationSec*1000) : null;
      await update(stateRef(roomCode), {
        phase,
        endsAt,
        ...extra
      });
      // yeni fazda ‚Äúkonu≈üma i≈üaretleri‚Äù sƒ±fƒ±rlansƒ±n
      lastSpokenMark.clear();
    }

    function startTickLoop(){
      if (tickHandle) return;
      tickHandle = setInterval(async ()=>{
        if (!roomCode) return;

        // Timer UI
        const endsAt = state?.endsAt ?? null;
        const remain = endsAt ? (endsAt - nowMs()) : null;
        el("timer").textContent = endsAt ? fmt(remain) : "--:--";

        // TTS reminder (only discussion/voting)
        if (endsAt && remain != null && remain > 0){
          const sec = Math.ceil(remain/1000);
          // 60sn
          if (sec === 60 && !lastSpokenMark.has("60")){
            lastSpokenMark.add("60");
            speakTR("Bir dakika kaldƒ±.");
          }
          // 10sn
          if (sec === 10 && !lastSpokenMark.has("10")){
            lastSpokenMark.add("10");
            speakTR("On saniye.");
          }
        }

        // Majority requests during discussion
        if (state?.phase === PHASE.DISCUSSION){
          await maybeStartVotingByMajority();
          await maybeFastNightByMajority();
        }

        // Phase auto advance by time
        if (endsAt && nowMs() >= endsAt){
          await advanceByTimeout();
        }

        // Night stage auto advance if all actors acted
        if (state?.phase === PHASE.NIGHT_KILL) await maybeAdvanceNightIfComplete("kill");
        if (state?.phase === PHASE.NIGHT_DOCTOR) await maybeAdvanceNightIfComplete("protect");
        if (state?.phase === PHASE.NIGHT_DETECTIVE) await maybeAdvanceNightIfComplete("investigate");

        // Voting can end early if all alive voted
        if (state?.phase === PHASE.VOTING) await maybeEndVotingIfAllVoted();

      }, 250);
    }

    async function readRoles(){
      const snap = await get(ref(db, `rooms/${roomCode}/secret/roles`));
      return snap.exists() ? snap.val() : {};
    }

    async function maybeStartVotingByMajority(){
      const alive = aliveUids(players);
      const maj = strictMajority(alive.length);

      const reqSnap = await get(requestsVoteRef(roomCode));
      const req = reqSnap.exists() ? reqSnap.val() : {};
      const count = Object.keys(req||{}).length;

      if (count >= maj){
        // start voting
        settings = (await get(settingsRef(roomCode))).val() || settings;
        await set(votingVotesRef(roomCode), null);
        await set(requestsVoteRef(roomCode), null);
        await enterPhase(PHASE.VOTING, settings.voteSec, {
          hostText: `Oylama ba≈üladƒ±. (${settings.voteSec} sn)`,
          awakeRole: null
        });
        uiText("Oylama ba≈üladƒ±.", true);
      }
    }

    async function maybeFastNightByMajority(){
      const alive = aliveUids(players);
      const maj = strictMajority(alive.length);

      const reqSnap = await get(requestsFastNightRef(roomCode));
      const req = reqSnap.exists() ? reqSnap.val() : {};
      const count = Object.keys(req||{}).length;

      if (count >= maj){
        await set(requestsFastNightRef(roomCode), null);
        await startNightSequence();
      }
    }

    async function advanceByTimeout(){
      switch(state?.phase){
        case PHASE.DISCUSSION:
          await startNightSequence();
          break;
        case PHASE.VOTING:
          await resolveVotingAndGoNight();
          break;
        case PHASE.NIGHT_KILL:
        case PHASE.NIGHT_DOCTOR:
        case PHASE.NIGHT_DETECTIVE:
          await advanceNightStage(); // s√ºre dolduysa bir sonraki role ge√ß
          break;
        case PHASE.MORNING:
          // morning kƒ±sa; buraya pek gelmez
          break;
      }
    }

    async function startNightSequence(){
      settings = (await get(settingsRef(roomCode))).val() || settings;
      await set(ref(db, `rooms/${roomCode}/night/actions`), null);
      await set(ref(db, `rooms/${roomCode}/requests`), null);

      // kill stage
      await enterPhase(PHASE.NIGHT_KILL, settings.nightSec, {
        hostText: "Gece oldu. Katiller uyanƒ±yor.",
        awakeRole: ROLES.KILLER
      });
      uiText("Gece oldu. Katiller uyanƒ±yor. Kurban se√ßin.", true);
    }

    async function maybeAdvanceNightIfComplete(kind){
      // kind: kill/protect/investigate
      const roles = await readRoles();
      const alive = aliveUids(players);

      const actors = alive.filter(uid => roles?.[uid]?.role === roleForKind(kind));
      if (!actors.length){
        // bu rolden kimse yoksa direkt ilerle
        await advanceNightStage();
        return;
      }

      const actionsSnap = await get(ref(db, `rooms/${roomCode}/night/actions/${kind}`));
      const actions = actionsSnap.exists() ? actionsSnap.val() : {};

      // tamam sayƒ±lmasƒ± i√ßin t√ºm akt√∂rler aksiyon g√∂ndermi≈ü olmalƒ±
      const done = actors.every(uid => !!actions?.[uid]);
      if (done){
        await advanceNightStage();
      }
    }

    function roleForKind(kind){
      if (kind==="kill") return ROLES.KILLER;
      if (kind==="protect") return ROLES.DOCTOR;
      if (kind==="investigate") return ROLES.DETECTIVE;
      return null;
    }

    async function advanceNightStage(){
      settings = (await get(settingsRef(roomCode))).val() || settings;
      if (state?.phase === PHASE.NIGHT_KILL){
        // doctor varsa
        if (settings.includeDoctor){
          await enterPhase(PHASE.NIGHT_DOCTOR, settings.nightSec, {
            hostText: "Doktor uyanƒ±yor.",
            awakeRole: ROLES.DOCTOR
          });
          uiText("Doktor uyan. Birini koru.", true);
          return;
        }
        // yoksa detective
        if (settings.includeDetective){
          await enterPhase(PHASE.NIGHT_DETECTIVE, settings.nightSec, {
            hostText: "Dedektif uyanƒ±yor.",
            awakeRole: ROLES.DETECTIVE
          });
          uiText("Dedektif uyan. Birini sorgula.", true);
          return;
        }
        // hi√ßbiri yoksa sabah √ß√∂z
        await resolveNightAndGoMorning();
        return;
      }

      if (state?.phase === PHASE.NIGHT_DOCTOR){
        if (settings.includeDetective){
          await enterPhase(PHASE.NIGHT_DETECTIVE, settings.nightSec, {
            hostText: "Dedektif uyanƒ±yor.",
            awakeRole: ROLES.DETECTIVE
          });
          uiText("Dedektif uyan. Birini sorgula.", true);
          return;
        }
        await resolveNightAndGoMorning();
        return;
      }

      if (state?.phase === PHASE.NIGHT_DETECTIVE){
        await resolveNightAndGoMorning();
        return;
      }
    }

    async function resolveNightAndGoMorning(){
      const roles = await readRoles();
      settings = (await get(settingsRef(roomCode))).val() || settings;

      // read actions
      const [killSnap, protectSnap, invSnap] = await Promise.all([
        get(nightActionsKillRef(roomCode)),
        get(nightActionsProtectRef(roomCode)),
        get(nightActionsInvestigateRef(roomCode)),
      ]);
      const killMap = killSnap.exists() ? killSnap.val() : {};
      const protectMap = protectSnap.exists() ? protectSnap.val() : {};
      const investigateMap = invSnap.exists() ? invSnap.val() : {};

      // doctor self-protect limit enforce (host-side)
      for (const [docUid, targetUid] of Object.entries(protectMap||{})){
        if (docUid === targetUid){
          const used = Number(players?.[docUid]?.doctorSelfProtectUsed || 0);
          if (used >= (settings.doctorSelfSaveMax ?? 1)){
            // hakkƒ± yoksa korumayƒ± ge√ßersiz say
            protectMap[docUid] = null;
          } else {
            // hakkƒ± varsa t√ºket
            await update(playerRef(roomCode, docUid), { doctorSelfProtectUsed: used + 1 });
          }
        }
      }

      // resolve
      const res = resolveNight({
        playersObj: players,
        rolesByUid: roles,
        killMap,
        protectMap,
        settings
      });

      // apply death
      let deadUid = null;
      if (res.diedUid){
        deadUid = res.diedUid;
        await update(playerRef(roomCode, deadUid), { alive:false, diedAt: nowMs() });
      }

      // detective inbox
      for (const [detUid, targetUid] of Object.entries(investigateMap||{})){
        if (!targetUid) continue;
        const role = roles?.[targetUid]?.role || "UNKNOWN";
        const targetName = players?.[targetUid]?.name || "Oyuncu";
        await update(secretRoleRef(roomCode, detUid), {
          inbox: { t: nowMs(), msg: `${targetName} rol√º: ${ROLE_TR[role] || role}` }
        });
      }

      // win check (fresh players)
      const freshPlayersSnap = await get(playersRef(roomCode));
      const freshPlayers = freshPlayersSnap.exists() ? freshPlayersSnap.val() : players;

      const win = computeWin(freshPlayers, roles);
      if (win.ended){
        const msg = (win.winner==="TOWN")
          ? "Oyun bitti. Masumlar kazandƒ±."
          : "Oyun bitti. Katiller kazandƒ±.";
        await enterPhase(PHASE.ENDED, 0, { hostText: msg, awakeRole:null, endsAt:null });
        uiText(msg, true);
        return;
      }

      // morning announce
      const deadName = deadUid ? (freshPlayers?.[deadUid]?.name || "Bir oyuncu") : null;
      const morning = deadUid
        ? `Sabah oldu. D√ºn gece ${deadName} √∂l√º bulundu.`
        : "Sabah oldu. Bu gece kimse √∂lmedi.";

      await enterPhase(PHASE.MORNING, 3, {
        hostText: morning,
        awakeRole: null,
        endsAt: nowMs()+3000
      });
      uiText(morning, true);

      // go discussion
      const nextDay = (state?.day ?? 1) + 1;
      setTimeout(async ()=>{
        settings = (await get(settingsRef(roomCode))).val() || settings;
        await enterPhase(PHASE.DISCUSSION, settings.discussionSec, {
          day: nextDay,
          hostText: `G√ºn ${nextDay}: Tartƒ±≈üma ba≈üladƒ±. (${settings.discussionSec} sn)`,
          awakeRole: null
        });
        uiText(`G√ºn ${nextDay}. Tartƒ±≈üma ba≈üladƒ±.`, true);
      }, 3100);
    }

    async function maybeEndVotingIfAllVoted(){
      const roles = await readRoles();
      const alive = aliveUids(players);
      const votesSnap = await get(votingVotesRef(roomCode));
      const votes = votesSnap.exists() ? votesSnap.val() : {};
      const votedCount = Object.keys(votes||{}).length;

      if (votedCount >= alive.length && alive.length > 0){
        await resolveVotingAndGoNight();
      }
    }

    async function resolveVotingAndGoNight(){
      settings = (await get(settingsRef(roomCode))).val() || settings;

      const votesSnap = await get(votingVotesRef(roomCode));
      const votes = votesSnap.exists() ? votesSnap.val() : {};

      const alive = aliveUids(players);
      const maj = strictMajority(alive.length);

      const { best, bestCount, tie } = pickMostVoted(votes);

      if (!best || tie || best === ACTIONS.SKIP_VOTE || bestCount < maj){
        uiText("Oylama bitti: Kimse elenmedi. Geceye ge√ßiliyor.", true);
        await startNightSequence();
        return;
      }

      const name = players?.[best]?.name || "Oyuncu";
      await update(playerRef(roomCode, best), { alive:false, eliminatedAt: nowMs() });

      // win check after elimination
      const roles = await readRoles();
      const freshPlayersSnap = await get(playersRef(roomCode));
      const freshPlayers = freshPlayersSnap.exists() ? freshPlayersSnap.val() : players;

      const win = computeWin(freshPlayers, roles);
      if (win.ended){
        const msg = (win.winner==="TOWN")
          ? `${name} elendi. Oyun bitti. Masumlar kazandƒ±.`
          : `${name} elendi. Oyun bitti. Katiller kazandƒ±.`;
        await enterPhase(PHASE.ENDED, 0, { hostText: msg, awakeRole:null, endsAt:null });
        uiText(msg, true);
        return;
      }

      uiText(`${name} elendi. (Rol a√ßƒ±klanmadƒ±.) Geceye ge√ßiliyor.`, true);
      await startNightSequence();
    }

    el("btnCreate").addEventListener("click", createRoom);
    el("btnStart").addEventListener("click", startGameOnce);

    ensureAuth().then(()=> uiText("Giri≈ü hazƒ±r. Oda olu≈ütur.", false));
  </script>
</body>
</html>
