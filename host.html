<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Shadow City — Host</title>
  <link rel="stylesheet" href="./styles.css"/>
</head>
<body>
  <div class="shell">
    <header class="topbar">
      <div class="brand">
        <div class="brand__title">SHADOW CITY — HOST</div>
        <div class="brand__subtitle">Moderatör ekranı (TV/PC)</div>
      </div>
      <a class="pill" href="./index.html">↩ Ana Menü</a>
    </header>

    <main class="stack">
      <section class="card stack">
        <h2 class="h2">Oda Kur</h2>
        <div class="row">
          <div>
            <label>Host adı (opsiyonel)</label>
            <input id="hostName" placeholder="HOST" value="HOST"/>
          </div>
          <div>
            <label>Oluştur</label>
            <button class="btn btn-primary" id="btnCreateRoom">ODA OLUŞTUR</button>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Katil sayısı</label>
            <select id="killerCount">
              <option value="1">1</option>
              <option value="2">2</option>
            </select>
          </div>
          <div>
            <label>Dedektif</label>
            <select id="includeDetective">
              <option value="true">Var</option>
              <option value="false">Yok</option>
            </select>
          </div>
          <div>
            <label>Doktor</label>
            <select id="includeDoctor">
              <option value="true">Var</option>
              <option value="false">Yok</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Tartışma süresi (sn)</label>
            <input id="discussionSec" value="120" />
          </div>
          <div>
            <label>Gece aksiyon süresi (sn)</label>
            <input id="nightSec" value="45" />
          </div>
          <div>
            <label>Oylama süresi (sn)</label>
            <input id="voteSec" value="45" />
          </div>
        </div>

        <div class="row">
          <div>
            <label>Katil “Kimseyi öldürme” seçeneği</label>
            <select id="allowNoKill">
              <option value="true">Açık</option>
              <option value="false">Kapalı</option>
            </select>
          </div>
          <div>
            <label>Doktor kendini koruma hakkı</label>
            <select id="doctorSelfSaveMax">
              <option value="0">0</option>
              <option value="1" selected>1</option>
              <option value="2">2</option>
            </select>
          </div>
        </div>

        <div class="notice">
          <div class="muted tiny">Oda Kodu</div>
          <div class="big" id="roomCodeText">—</div>
          <div class="tiny muted">Oyuncular şu adresten girsin: <strong>/player.html</strong></div>
        </div>
      </section>

      <section class="grid2">
        <div class="card stack">
          <h2 class="h2">Durum</h2>
          <div class="kpi">
            <div class="box">
              <div class="num" id="kpiAlive">0</div>
              <div class="lbl">Hayatta</div>
            </div>
            <div class="box">
              <div class="num" id="kpiDead">0</div>
              <div class="lbl">Elendi</div>
            </div>
            <div class="box">
              <div class="num" id="kpiPhase">—</div>
              <div class="lbl">Faz</div>
            </div>
            <div class="box">
              <div class="num" id="kpiDay">—</div>
              <div class="lbl">Gün</div>
            </div>
          </div>

          <div class="notice">
            <div class="muted tiny">Süre</div>
            <div class="big" id="timerText">—</div>
          </div>

          <div class="notice" id="hostNarration">
            <strong>Anons:</strong>
            <div class="muted" id="hostText">Oda oluşturulmadı.</div>
          </div>
        </div>

        <div class="card stack">
          <h2 class="h2">Oyuncular</h2>
          <div class="list" id="playersList"></div>
        </div>
      </section>
    </main>
  </div>

  <script type="module">
    import {
      ensureAuth,
      generateRoomCode,
      joinRoomAsHost,
      settingsRef,
      stateRef,
      playersRef,
      playerRef,
      myRoleRef,
      voteCallRequestsRef,
      votingVotesRef,
      nightActionsRef,
      nightResultsRef,
      listen,
      set,
      update,
      get,
      ref,
      db
    } from "./firebase.js";

    import {
      ROLES,
      ROLE_LABEL_TR,
      ACTIONS,
      speakTR,
      clampInt,
      makeRoleDeck,
      aliveUids,
      computeWin,
      strictMajority,
      pickMostVoted,
      nowMs,
      mergeSettings,
      resolveNight
    } from "./shared.js";

    let roomCode = null;
    let creatorUid = null;

    let players = {};
    let settings = null;
    let stateCache = null;
    let secretRoles = null;
    let voteCallRequests = {};
    let votesCache = {};
    let nightActionsCache = {};

    let tickHandle = null;
    let countdownHandle = null;

    const el = (id) => document.getElementById(id);

    const NIGHT_STAGES = ["kill", "protect", "investigate"];

    function escapeHtml(s){
      return String(s || "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#39;");
    }

    function setHostText(text, speak = false){
      el("hostText").textContent = text;
      if (speak) speakTR(text);
    }

    function getSettingsFromUI(){
      return mergeSettings({
        killerCount: clampInt(el("killerCount").value, 1, 6, 1),
        includeDetective: el("includeDetective").value === "true",
        includeDoctor: el("includeDoctor").value === "true",

        discussionSec: clampInt(el("discussionSec").value, 15, 9999, 120),
        nightSec: clampInt(el("nightSec").value, 10, 9999, 45),
        voteSec: clampInt(el("voteSec").value, 10, 9999, 45),

        allowNoKill: el("allowNoKill").value === "true",
        doctorSelfSaveMax: clampInt(el("doctorSelfSaveMax").value, 0, 9, 1),
      });
    }

    function setPhaseUI(st){
      el("kpiPhase").textContent = st?.phase || "—";
      el("kpiDay").textContent = st?.day ? String(st.day) : "—";
    }

    function renderPlayers(){
      const list = el("playersList");
      const entries = Object.entries(players || {}).filter(([,p]) => p && !p.isHost);

      let alive = 0, dead = 0;
      const rows = entries.map(([uid, p]) => {
        if (p.alive) alive++; else dead++;
        return `
          <div class="item">
            <div>
              <div><strong>${escapeHtml(p.name || "Player")}</strong></div>
              <div class="tiny muted">${uid.slice(0,6)}…</div>
              ${p.alive ? "" : `<div class="tiny muted">⛔ Elendi</div>`}
            </div>
            <div class="badge ${p.alive ? "badge--alive":"badge--dead"}">
              ${p.alive ? "Alive" : "Dead"}
            </div>
          </div>
        `;
      }).join("");

      list.innerHTML = rows || `<div class="item"><div class="muted">Henüz oyuncu yok.</div></div>`;

      el("kpiAlive").textContent = String(alive);
      el("kpiDead").textContent = String(dead);
    }

    function updateTimerUI(){
      if (countdownHandle) clearInterval(countdownHandle);

      const refresh = () => {
        if (!stateCache?.endsAt) {
          el("timerText").textContent = "—";
          return;
        }
        const remaining = Math.max(0, Math.floor((stateCache.endsAt - nowMs()) / 1000));
        el("timerText").textContent = `${remaining} sn`;
      };

      refresh();
      countdownHandle = setInterval(refresh, 1000);
    }

    async function readSettings(){
      if (!roomCode) return getSettingsFromUI();
      const sSnap = await get(settingsRef(roomCode));
      return mergeSettings(sSnap.exists() ? sSnap.val() : getSettingsFromUI());
    }

    async function ensureSecretRoles(){
      if (secretRoles) return secretRoles;
      if (!roomCode) return {};
      const snap = await get(ref(db, `rooms/${roomCode}/secret/roles`));
      secretRoles = snap.exists() ? (snap.val() || {}) : {};
      return secretRoles;
    }

    function aliveRoleUids(role){
      const roles = secretRoles || {};
      return Object.entries(players || {})
        .filter(([uid, p]) => p && p.alive && !p.isHost && roles?.[uid]?.role === role)
        .map(([uid]) => uid);
    }

    function setStateCache(st){
      stateCache = st || {};
      setPhaseUI(stateCache);
      if (stateCache?.hostText) setHostText(stateCache.hostText, false);
      updateTimerUI();
    }

    function hasVoteMajority(){
      const alive = aliveUids(players).length;
      if (alive <= 0) return false;
      const maj = strictMajority(alive);
      const reqCount = Object.keys(voteCallRequests || {}).length;
      return reqCount >= maj;
    }

    function everyoneVoted(){
      const aliveList = aliveUids(players);
      const total = aliveList.length;
      if (total === 0) return false;
      const voteCount = aliveList.filter(uid => votesCache?.[uid]).length;
      return voteCount >= total;
    }

    function nightStageExpectedActions(stage){
      if (stage === "kill") return aliveRoleUids(ROLES.KILLER).length || 0;
      if (stage === "protect") return aliveRoleUids(ROLES.DOCTOR).length || 0;
      if (stage === "investigate") return aliveRoleUids(ROLES.DETECTIVE).length || 0;
      return 0;
    }

    function nightStageReady(stage){
      const actions = nightActionsCache?.[stage] || {};
      const expected = nightStageExpectedActions(stage);
      if (expected <= 0) return false;
      return Object.keys(actions || {}).length >= expected;
    }

    async function enterPhase(phase, extra = {}){
      if (!roomCode) return;
      const payload = {
        phase,
        day: extra.day ?? stateCache?.day ?? 0,
        nightStage: extra.nightStage ?? null,
        hostText: extra.hostText ?? stateCache?.hostText ?? "",
        endsAt: extra.endsAt ?? null,
      };
      await update(stateRef(roomCode), payload);
      setStateCache({ ...(stateCache || {}), ...payload });
    }

    function stageNarration(stage, s){
      const sec = s?.nightSec || 45;
      if (stage === "kill") {
        return {
          hostText: `Gece oldu. Katil(ler) uyanıyor. Kurban seçin. Süre: ${sec} sn.`,
          tts: "Gece oldu. Katiller uyanıyor. Kurban seçin."
        };
      }
      if (stage === "protect") {
        return {
          hostText: `Katil(ler) uyusun. Doktor uyanıyor. Koruyacağını seç. Süre: ${sec} sn.`,
          tts: "Katiller uyusun. Doktor uyanıyor. Koruyacağını seç."
        };
      }
      if (stage === "investigate") {
        return {
          hostText: `Doktor uyusun. Dedektif uyanıyor. Şüpheliyi sorgula. Süre: ${sec} sn.`,
          tts: "Doktor uyusun. Dedektif uyanıyor. Şüpheliyi sorgula."
        };
      }
      return { hostText: "Gece aşaması.", tts: "Gece aşaması." };
    }

    async function advanceNightStage(){
      if (!roomCode) return;
      settings = await readSettings();
      await ensureSecretRoles();
      const st = stateCache || {};
      if (st.phase !== "night") return;

      const current = st.nightStage || "kill";
      const idx = NIGHT_STAGES.indexOf(current);
      const next = (idx >= 0 && idx < NIGHT_STAGES.length - 1) ? NIGHT_STAGES[idx + 1] : null;

      if (!next) {
        await resolveNightAndGoMorning();
        return;
      }

      const skipProtect = next === "protect" && settings.includeDoctor === false;
      const skipInvestigate = next === "investigate" && settings.includeDetective === false;

      if (skipProtect) {
        if (settings.includeDetective === false) {
          await resolveNightAndGoMorning();
          return;
        }
        const nar = stageNarration("investigate", settings);
        await enterPhase("night", {
          nightStage: "investigate",
          hostText: nar.hostText,
          endsAt: nowMs() + settings.nightSec * 1000,
        });
        speakTR(nar.tts);
        return;
      }

      if (skipInvestigate) {
        await resolveNightAndGoMorning();
        return;
      }

      const nar = stageNarration(next, settings);
      await enterPhase("night", {
        nightStage: next,
        hostText: nar.hostText,
        endsAt: nowMs() + settings.nightSec * 1000,
      });
      speakTR(nar.tts);
    }

    async function createRoom(){
      const auth = await ensureAuth();
      creatorUid = auth.uid;

      roomCode = generateRoomCode(6);
      el("roomCodeText").textContent = roomCode;

      const hostName = el("hostName").value || "HOST";
      await joinRoomAsHost(roomCode, hostName);

      settings = getSettingsFromUI();

      await set(settingsRef(roomCode), {
        creatorUid,
        createdAt: nowMs(),
        ...settings
      });

      await set(stateRef(roomCode), {
        phase: "waiting",
        day: 0,
        createdAt: nowMs(),
        hostText: "Oda hazır. Oyuncuların katılması bekleniyor.",
        endsAt: null
      });

      setHostText(`Oda oluşturuldu. Kod: ${roomCode}. Oyuncular katılsın.`, true);
      wireListeners();
      startTicking();
    }

    let unsubPlayers = null, unsubState = null, unsubVoteCall = null, unsubVotes = null, unsubNightActions = null;

    function wireListeners(){
      if (!roomCode) return;

      if (unsubPlayers) unsubPlayers();
      if (unsubState) unsubState();
      if (unsubVoteCall) unsubVoteCall();
      if (unsubVotes) unsubVotes();
      if (unsubNightActions) unsubNightActions();

      unsubPlayers = listen(playersRef(roomCode), (val) => {
        players = val || {};
        renderPlayers();
      });

      unsubState = listen(stateRef(roomCode), (st) => {
        setStateCache(st || {});
      });

      unsubVoteCall = listen(voteCallRequestsRef(roomCode), (reqs) => {
        voteCallRequests = reqs || {};
      });

      unsubVotes = listen(votingVotesRef(roomCode), (votes) => {
        votesCache = votes || {};
      });

      unsubNightActions = listen(nightActionsRef(roomCode), (actions) => {
        nightActionsCache = actions || {};
      });
    }

    async function bulkUpdate(pathMap){
      await update(ref(db, "/"), pathMap);
    }

    async function dealRolesAndStart(){
      if (!roomCode) return;

      settings = await readSettings();

      const alive = aliveUids(players);
      if (alive.length < 3){
        setHostText("En az 3 oyuncu gerekli.", true);
        return;
      }

      const deck = makeRoleDeck(alive, settings);

      const pathMap = {};

      alive.forEach((uid, i) => {
        pathMap[`rooms/${roomCode}/players/${uid}/alive`] = true;
        pathMap[`rooms/${roomCode}/players/${uid}/doctorSelfProtectUsed`] = 0;

        pathMap[`rooms/${roomCode}/secret/roles/${uid}`] = {
          role: deck[i],
          inbox: { t: nowMs(), msg: "Rolün dağıtıldı. Oyun başlıyor." }
        };
      });

      pathMap[`rooms/${roomCode}/voting/votes`] = null;
      pathMap[`rooms/${roomCode}/voting/result`] = null;
      pathMap[`rooms/${roomCode}/day/voteCall/requests`] = null;
      pathMap[`rooms/${roomCode}/night/actions`] = null;
      pathMap[`rooms/${roomCode}/night/results`] = null;

      pathMap[`rooms/${roomCode}/state`] = {
        phase: "discussion",
        day: 1,
        startedAt: nowMs(),
        hostText: `Gün 1: Tartışma başladı. Süre: ${settings.discussionSec} sn.`,
        endsAt: nowMs() + settings.discussionSec * 1000
      };

      await bulkUpdate(pathMap);
      secretRoles = null; // force reload later
      setHostText("Roller dağıtıldı. Gün 1 tartışma başladı.", true);
      speakTR("Gün bir. Tartışma başladı.");
    }

    async function startVoting(reasonText = "Oylama başladı."){
      if (!roomCode) return;
      settings = await readSettings();

      await set(votingVotesRef(roomCode), null);
      await set(voteCallRequestsRef(roomCode), null);

      await enterPhase("voting", {
        hostText: `${reasonText} Süre: ${settings.voteSec} sn.`,
        endsAt: nowMs() + settings.voteSec * 1000,
      });

      speakTR("Oylama başladı.");
    }

    async function startNight(){
      if (!roomCode) return;

      settings = await readSettings();

      await set(nightActionsRef(roomCode), null);

      const nar = stageNarration("kill", settings);

      await enterPhase("night", {
        nightStage: "kill",
        hostText: nar.hostText,
        endsAt: nowMs() + settings.nightSec * 1000,
      });

      speakTR(nar.tts);
    }

    async function resolveNightAndGoMorning(){
      if (!roomCode) return;

      settings = await readSettings();
      await ensureSecretRoles();

      const actionsSnap = await get(nightActionsRef(roomCode));
      const actions = actionsSnap.exists() ? actionsSnap.val() : {};
      nightActionsCache = actions;

      const killMap = actions?.kill || {};
      const protectMap = actions?.protect || {};
      const investigateMap = actions?.investigate || {};

      // killers: most-picked; tie => NO_KILL if allowed else null
      const tally = new Map();
      for (const target of Object.values(killMap)) {
        if (!target) continue;
        if (target === ACTIONS.NO_KILL) continue;
        tally.set(target, (tally.get(target) || 0) + 1);
      }

      let killTargetUid = null;
      let best = 0;
      let tie = false;
      for (const [t, c] of tally.entries()){
        if (c > best){ best = c; killTargetUid = t; tie = false; }
        else if (c === best){ tie = true; }
      }
      if (tie) killTargetUid = (settings.allowNoKill ? ACTIONS.NO_KILL : null);

      // doctor selection (first valid)
      let doctorUid = null;
      let doctorSaveUid = null;
      for (const [uid, t] of Object.entries(protectMap || {})) {
        if (!t) continue;
        doctorUid = uid;
        doctorSaveUid = t;
        break;
      }

      const doctorState = doctorUid
        ? { selfSaveUsed: Number(players?.[doctorUid]?.doctorSelfProtectUsed || 0) }
        : { selfSaveUsed: 0 };

      const nightRes = resolveNight({
        killerChoiceUid: killTargetUid,
        doctorSaveUid,
        doctorUid,
        playersObj: players,
        doctorState,
        settings
      });

      if (nightRes.reason === "DOCTOR_SELF_SAVE" && doctorUid) {
        const used = Number(players?.[doctorUid]?.doctorSelfProtectUsed || 0);
        await update(playerRef(roomCode, doctorUid), { doctorSelfProtectUsed: used + 1 });
      }

      let deadUid = null;
      if (nightRes.diedUid) {
        deadUid = nightRes.diedUid;
        await update(playerRef(roomCode, deadUid), { alive: false, diedAt: nowMs() });
      }

      // detective inbox
      for (const [detUid, targetUid] of Object.entries(investigateMap || {})) {
        if (!targetUid) continue;
        const targetRole = secretRoles?.[targetUid]?.role || "UNKNOWN";
        const msg = `${(players?.[targetUid]?.name || "Oyuncu")} rolü: ${ROLE_LABEL_TR[targetRole] || targetRole}`;
        await update(myRoleRef(roomCode, detUid), { inbox: { t: nowMs(), msg } });
      }

      // public night result (no role reveal)
      const deadName = deadUid ? (players?.[deadUid]?.name || "Bir oyuncu") : null;
      let morningText = "Sabah oldu. Bu gece kimse ölmedi.";
      if (deadUid) morningText = `Sabah oldu. Dün gece ${deadName} ölü bulundu.`;

      await set(nightResultsRef(roomCode), {
        t: nowMs(),
        deadUid: deadUid || null,
        deadName: deadName || null,
        saved: !!nightRes.saved,
        killAttempted: !!killTargetUid,
        reason: nightRes.reason
      });

      // win check (fresh players)
      const [playersSnap, secretRolesSnap] = await Promise.all([
        get(playersRef(roomCode)),
        get(ref(db, `rooms/${roomCode}/secret/roles`))
      ]);

      const freshPlayers = playersSnap.exists() ? playersSnap.val() : players;
      const freshRoles = secretRolesSnap.exists() ? secretRolesSnap.val() : secretRoles;

      const win = computeWin(freshPlayers, freshRoles);
      if (win.ended) {
        const winnerText = win.winner === "TOWN"
          ? "Oyun bitti. Vatandaşlar kazandı. Katiller yakalandı."
          : "Oyun bitti. Katiller kazandı. Şehir düştü.";

        await enterPhase("ended", {
          hostText: winnerText,
          endsAt: null,
        });

        speakTR(winnerText);
        return;
      }

      await enterPhase("discussion", {
        day: (stateCache?.day || 1) + 1,
        nightStage: null,
        hostText: morningText + " Tartışma başladı.",
        endsAt: nowMs() + settings.discussionSec * 1000,
      });

      speakTR(morningText);
    }

    async function resolveVote(){
      if (!roomCode) return;
      settings = await readSettings();

      const votesSnap = await get(votingVotesRef(roomCode));
      const votes = votesSnap.exists() ? votesSnap.val() : {};
      votesCache = votes;

      const { best, bestCount, tie } = pickMostVoted(votes);

      const alive = aliveUids(players);
      const maj = strictMajority(alive.length);

      // tie / SKIP / no majority => no elimination
      if (!best || tie || best === ACTIONS.SKIP_VOTE || bestCount < maj) {
        const txt = "Oylama sonucu: Kimse elenmedi. Tartışma devam ediyor.";
        await set(votingVotesRef(roomCode), null);
        await enterPhase("discussion", {
          hostText: txt,
          endsAt: nowMs() + settings.discussionSec * 1000,
        });
        speakTR(txt);
        return;
      }

      // eliminate
      const name = players?.[best]?.name || "Oyuncu";
      await update(playerRef(roomCode, best), { alive: false, eliminatedAt: nowMs() });

      const [playersSnap, secretRolesSnap] = await Promise.all([
        get(playersRef(roomCode)),
        get(ref(db, `rooms/${roomCode}/secret/roles`))
      ]);

      const freshPlayers = playersSnap.exists() ? playersSnap.val() : players;
      const secretRoles = secretRolesSnap.exists() ? secretRolesSnap.val() : {};

      const win = computeWin(freshPlayers, secretRoles);

      if (win.ended) {
        const winnerText = win.winner === "TOWN"
          ? "Oyun bitti. Vatandaşlar kazandı."
          : "Oyun bitti. Katiller kazandı.";

        const full = `${name} elendi. ${winnerText}`;

        await set(votingVotesRef(roomCode), null);
        await enterPhase("ended", {
          hostText: full,
          endsAt: null,
        });

        speakTR(full);
        return;
      }

      const txt = `${name} elendi. (Rol açıklanmadı.) Tartışma devam ediyor.`;
      await set(votingVotesRef(roomCode), null);
      await enterPhase("discussion", {
        hostText: txt,
        endsAt: nowMs() + settings.discussionSec * 1000,
      });
      speakTR(`${name} elendi. Tartışma devam ediyor.`);
    }

    async function tick(){
      if (!roomCode) return;
      const st = stateCache || {};
      const phase = st.phase || "waiting";

      // auto start when enough players
      if (phase === "waiting") {
        if (aliveUids(players).length >= 3) {
          await dealRolesAndStart();
        }
        return;
      }

      if (phase === "discussion") {
        if (hasVoteMajority()) {
          await startVoting("Oylama isteği çoğunluğa ulaştı. Oylama başladı.");
          return;
        }

        if (st.endsAt && nowMs() >= st.endsAt) {
          await startNight();
          return;
        }
        return;
      }

      if (phase === "voting") {
        if (everyoneVoted() || (st.endsAt && nowMs() >= st.endsAt)) {
          await resolveVote();
        }
        return;
      }

      if (phase === "night") {
        await ensureSecretRoles();
        const stage = st.nightStage || "kill";
        const deadlineReached = st.endsAt && nowMs() >= st.endsAt;
        const ready = nightStageReady(stage);

        if (deadlineReached || ready) {
          await advanceNightStage();
        }
      }
    }

    function startTicking(){
      if (tickHandle) clearInterval(tickHandle);
      tickHandle = setInterval(tick, 1000);
    }

    el("btnCreateRoom").addEventListener("click", createRoom);

    ensureAuth().then(() => setHostText("Giriş hazır. Oda oluştur.", false));
  </script>
</body>
</html>
