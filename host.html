<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Shadow City — Host</title>
  <link rel="stylesheet" href="./styles.css"/>
</head>
<body>

  <!-- SETUP -->
  <div class="centerScreen" id="setupScreen">
    <div class="wrap">
      <div class="bigTitle">HOST</div>
      <div class="sub">Odayı kur → oyuncular katılsın → başlat</div>

      <div style="height:14px"></div>

      <div class="card" style="padding:18px">
        <div class="row">
          <div class="col">
            <div class="label">Host adı</div>
            <input id="hostName" value="HOST"/>
          </div>
          <div class="col">
            <div class="label">Katil sayısı</div>
            <select id="killerCount">
              <option value="1">1</option>
              <option value="2">2</option>
            </select>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="row">
          <div class="col">
            <div class="label">Doktor</div>
            <select id="includeDoctor">
              <option value="true" selected>Var</option>
              <option value="false">Yok</option>
            </select>
          </div>
          <div class="col">
            <div class="label">Dedektif</div>
            <select id="includeDetective">
              <option value="true" selected>Var</option>
              <option value="false">Yok</option>
            </select>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="row">
          <div class="col">
            <div class="label">Tartışma (sn)</div>
            <input id="discussionSec" value="300"/>
          </div>
          <div class="col">
            <div class="label">Oylama (sn)</div>
            <input id="voteSec" value="45"/>
          </div>
          <div class="col">
            <div class="label">Gece (sn)</div>
            <input id="nightSec" value="45"/>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="row">
          <div class="col">
            <div class="label">NO KILL</div>
            <select id="allowNoKill">
              <option value="true" selected>Açık</option>
              <option value="false">Kapalı</option>
            </select>
          </div>
          <div class="col">
            <div class="label">Doktor kendini koruma</div>
            <select id="doctorSelfSaveMax">
              <option value="0">0</option>
              <option value="1" selected>1</option>
              <option value="2">2</option>
            </select>
          </div>
        </div>

        <div style="height:14px"></div>

        <button class="btn primary" id="btnCreate">ODA OLUŞTUR</button>

        <div style="height:12px"></div>

        <div class="card" style="padding:14px; background:rgba(0,0,0,.18)">
          <div class="label">ODA KODU</div>
          <div class="huge" id="roomCodeText">—</div>
          <div class="sub">Oyuncular: <b>/player.html</b></div>

          <div style="height:10px"></div>

          <div class="label">Oyuncular</div>
          <div class="list" id="playersList" style="margin-top:8px"></div>

          <div style="height:12px"></div>
          <button class="btn" id="btnStart" disabled>OYUNU BAŞLAT</button>
          <div class="sub" id="hint" style="margin-top:8px">En az 3 oyuncu katılmalı.</div>
        </div>
      </div>

      <div style="height:14px"></div>
      <a class="pill" href="./index.html">↩ Ana Menü</a>
    </div>
  </div>

  <!-- RUN (fullscreen timer) -->
  <div class="fullscreen hidden" id="runScreen">
    <div class="pill" id="runTopPill">—</div>
    <div class="huge" id="countdown">—</div>
    <div class="sub" id="runText">—</div>
  </div>

<script type="module">
  import {
    ensureAuth, generateRoomCode, joinRoomAsHost,
    settingsRef, stateRef, playersRef, playerRef,
    secretRolesRef, secretRoleRef,
    votingVotesRef, nightActionsRef, nightResultsRef,
    requestVoteStartRef, requestFastNightRef,
    hostHeartbeatRef,
    ref, db, get, set, update, listen, nowMs
  } from "./firebase.js";

  import {
    mergeSettings, clampInt, aliveUids, strictMajority,
    makeRoleDeck, computeWin, tallyMost,
    PHASE, ROLES, ROLE_TR, ACTIONS, speakTR, resolveNight
  } from "./shared.js";

  const el = (id)=>document.getElementById(id);

  let roomCode = null;
  let creatorUid = null;

  let players = {};
  let settings = null;
  let state = null;
  let rolesByUid = {};

  // -------- UI helpers ----------
  function showSetup(){ el("setupScreen").classList.remove("hidden"); el("runScreen").classList.add("hidden"); }
  function showRun(){ el("setupScreen").classList.add("hidden"); el("runScreen").classList.remove("hidden"); }

  function escapeHtml(s){
    return String(s||"").replaceAll("&","&amp;").replaceAll("<","&lt;")
      .replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#39;");
  }

  function fmt(msLeft){
    const s = Math.max(0, Math.floor(msLeft/1000));
    const mm = String(Math.floor(s/60)).padStart(2,"0");
    const ss = String(s%60).padStart(2,"0");
    return `${mm}:${ss}`;
  }

  // countdown loop
  let tmr = null;
  function startCountdownLoop(){
    if (tmr) clearInterval(tmr);
    tmr = setInterval(()=>{
      if (!state?.timerEndsAt) { el("countdown").textContent = "—"; return; }
      el("countdown").textContent = fmt(state.timerEndsAt - Date.now());
    }, 200);
  }

  function getSettingsFromUI(){
    return mergeSettings({
      killerCount: clampInt(el("killerCount").value, 1, 6, 1),
      includeDoctor: el("includeDoctor").value === "true",
      includeDetective: el("includeDetective").value === "true",
      discussionSec: clampInt(el("discussionSec").value, 30, 9999, 300),
      voteSec: clampInt(el("voteSec").value, 15, 9999, 45),
      nightSec: clampInt(el("nightSec").value, 10, 9999, 45),
      allowNoKill: el("allowNoKill").value === "true",
      doctorSelfSaveMax: clampInt(el("doctorSelfSaveMax").value, 0, 9, 1),
    });
  }

  function renderPlayersList(){
    const list = el("playersList");
    const entries = Object.entries(players||{}).filter(([,p])=>p && !p.isHost);

    list.innerHTML = entries.length ? entries.map(([uid,p])=>`
      <div class="item">
        <div>
          <b>${escapeHtml(p.name||"Oyuncu")}</b>
          <div class="sub">${uid.slice(0,6)}…</div>
        </div>
        <span class="badge ${p.alive ? "alive":"dead"}">${p.alive ? "LIVE":"OUT"}</span>
      </div>
    `).join("") : `<div class="sub">Henüz oyuncu yok.</div>`;

    const alive = aliveUids(players).length;
    el("btnStart").disabled = !(roomCode && alive >= 3);
    el("hint").textContent = alive >= 3 ? "Hazırsın." : "En az 3 oyuncu katılmalı.";
  }

  async function readSettings(){
    const snap = await get(settingsRef(roomCode));
    return mergeSettings(snap.exists() ? snap.val() : getSettingsFromUI());
  }

  async function readSecretRoles(){
    const snap = await get(secretRolesRef(roomCode));
    return snap.exists() ? (snap.val()||{}) : {};
  }

  // -------- Room create ----------
  async function createRoom(){
    const u = await ensureAuth();
    creatorUid = u.uid;

    roomCode = generateRoomCode(6);
    el("roomCodeText").textContent = roomCode;

    await joinRoomAsHost(roomCode, el("hostName").value || "HOST");

    settings = getSettingsFromUI();

    await set(settingsRef(roomCode), { creatorUid, createdAt: nowMs(), ...settings });

    await set(stateRef(roomCode), {
      phase: PHASE.WAITING,
      day: 0,
      hostText: "Oyuncular katılıyor…",
      timerEndsAt: null,
      createdAt: nowMs(),
    });

    // reset request nodes
    await update(ref(db, `rooms/${roomCode}`), {
      "requests/voteStart": null,
      "requests/fastNight": null,
      "voting/votes": null,
      "night/actions": null,
      "night/results": null,
      "secret/roles": null
    });

    wireSetupListeners();
    speakTR(`Oda kuruldu. Kod: ${roomCode}`);
  }

  let unsubPlayers=null, unsubState=null;

  function wireSetupListeners(){
    if (unsubPlayers) unsubPlayers();
    if (unsubState) unsubState();

    unsubPlayers = listen(playersRef(roomCode), (v)=>{ players=v||{}; renderPlayersList(); });
    unsubState = listen(stateRef(roomCode), (v)=>{ state=v||{}; });
  }

  // -------- Game start ----------
  async function startGame(){
    settings = await readSettings();

    const alive = aliveUids(players);
    if (alive.length < 3) return;

    // deal roles
    const deck = makeRoleDeck(alive, settings);
    const patch = {};

    alive.forEach((uid,i)=>{
      patch[`rooms/${roomCode}/players/${uid}/alive`] = true;
      patch[`rooms/${roomCode}/players/${uid}/doctorSelfProtectUsed`] = 0;

      patch[`rooms/${roomCode}/secret/roles/${uid}`] = {
        role: deck[i],
        inbox: { t: nowMs(), msg: "Rolün verildi. Host başlatıyor…" }
      };
    });

    // reset round nodes
    patch[`rooms/${roomCode}/voting/votes`] = null;
    patch[`rooms/${roomCode}/night/actions`] = null;
    patch[`rooms/${roomCode}/night/results`] = null;
    patch[`rooms/${roomCode}/requests/voteStart`] = null;
    patch[`rooms/${roomCode}/requests/fastNight`] = null;

    // go to discussion day 1
    patch[`rooms/${roomCode}/state`] = {
      phase: PHASE.DISCUSSION,
      day: 1,
      hostText: "Gün 1: Tartışma başladı.",
      timerEndsAt: nowMs() + settings.discussionSec * 1000,
      createdAt: nowMs(),
    };

    await update(ref(db,"/"), patch);

    // switch to run screen
    showRun();
    wireRunListeners();
    startCountdownLoop();

    speakTR("Gün bir. Tartışma başladı.");
  }

  // -------- RUN listeners + state machine ----------
  let unsubRunState=null, unsubRunPlayers=null, unsubReqVote=null, unsubReqFast=null;
  let machineTick=null;

  function wireRunListeners(){
    // stop previous
    if (unsubRunState) unsubRunState();
    if (unsubRunPlayers) unsubRunPlayers();
    if (unsubReqVote) unsubReqVote();
    if (unsubReqFast) unsubReqFast();
    if (machineTick) clearInterval(machineTick);

    unsubRunState = listen(stateRef(roomCode), (v)=>{ state=v||{}; renderRunTop(); });
    unsubRunPlayers = listen(playersRef(roomCode), (v)=>{ players=v||{}; });
    unsubReqVote = listen(requestVoteStartRef(roomCode), (v)=>{ /* value polled in tick */ });
    unsubReqFast = listen(requestFastNightRef(roomCode), (v)=>{ /* value polled in tick */ });

    machineTick = setInterval(hostStateMachine, 500);
    // heartbeat (opsiyonel)
    setInterval(()=> set(hostHeartbeatRef(roomCode), nowMs()).catch(()=>{}), 5000);
  }

  function renderRunTop(){
    const day = state?.day ?? "—";
    const phase = state?.phase || "—";
    el("runTopPill").textContent = `${String(phase).toUpperCase()} • GÜN ${day}`;
    el("runText").textContent = state?.hostText || "—";
  }

  async function hostStateMachine(){
    if (!roomCode || !state) return;

    // Timer bitti mi?
    const ended = state.timerEndsAt && Date.now() >= state.timerEndsAt;

    // Faz başına otomatik geçiş
    if (state.phase === PHASE.DISCUSSION) {
      // çoğunlukla vote veya night isteği
      const alive = aliveUids(players).length;
      const maj = strictMajority(alive);

      const [vs, ns] = await Promise.all([
        get(requestVoteStartRef(roomCode)),
        get(requestFastNightRef(roomCode))
      ]);

      const voteReq = vs.exists() ? Object.keys(vs.val()||{}).length : 0;
      const nightReq = ns.exists() ? Object.keys(ns.val()||{}).length : 0;

      if (voteReq >= maj) return startVotingAuto("Oyuncular oylama istedi.");
      if (nightReq >= maj) return startNightKillAuto("Oyuncular uyumak istedi.");

      if (ended) return startNightKillAuto("Süre doldu. Gece oluyor.");
      return;
    }

    if (state.phase === PHASE.VOTING) {
      // herkes oy verdiyse erken bitir
      const alive = aliveUids(players);
      const snap = await get(votingVotesRef(roomCode));
      const votes = snap.exists() ? (snap.val()||{}) : {};
      const votedCount = Object.keys(votes).length;

      if (votedCount >= alive.length) return resolveVotingAuto(votes);
      if (ended) return resolveVotingAuto(votes);
      return;
    }

    if (state.phase === PHASE.NIGHT_KILL || state.phase === PHASE.NIGHT_DOCTOR || state.phase === PHASE.NIGHT_DETECTIVE) {
      // gerekli rol sahipleri aksiyon verdiyse erken bitir
      const roles = await readSecretRoles();
      rolesByUid = roles || {};

      const actionSnap = await get(nightActionsRef(roomCode));
      const actions = actionSnap.exists() ? (actionSnap.val()||{}) : {};

      const alive = aliveUids(players);

      const killers = alive.filter(uid => rolesByUid?.[uid]?.role === ROLES.KILLER);
      const doctors = alive.filter(uid => rolesByUid?.[uid]?.role === ROLES.DOCTOR);
      const detectives = alive.filter(uid => rolesByUid?.[uid]?.role === ROLES.DETECTIVE);

      const kind =
        state.phase === PHASE.NIGHT_KILL ? "kill" :
        state.phase === PHASE.NIGHT_DOCTOR ? "protect" : "investigate";

      const needed =
        kind === "kill" ? killers :
        kind === "protect" ? doctors :
        detectives;

      const submitted = Object.keys(actions?.[kind] || {});
      const allDone = needed.length === 0 || needed.every(uid => submitted.includes(uid));

      if (allDone) return advanceNightStageAuto(actions, rolesByUid);
      if (ended) return advanceNightStageAuto(actions, rolesByUid);
      return;
    }

    if (state.phase === PHASE.MORNING) {
      if (ended) return startDiscussionNextDayAuto();
      return;
    }
  }

  // -------- Transitions ----------
  async function startVotingAuto(reason){
    settings = await readSettings();
    await set(votingVotesRef(roomCode), null);
    await set(requestVoteStartRef(roomCode), null);

    await update(stateRef(roomCode), {
      phase: PHASE.VOTING,
      hostText: reason || "Oylama başladı.",
      timerEndsAt: nowMs() + settings.voteSec * 1000
    });
    speakTR("Oylama başladı.");
  }

  async function startNightKillAuto(reason){
    settings = await readSettings();
    await set(nightActionsRef(roomCode), null);
    await set(requestFastNightRef(roomCode), null);

    await update(stateRef(roomCode), {
      phase: PHASE.NIGHT_KILL,
      hostText: reason || "Gece oldu. Katiller uyanıyor.",
      timerEndsAt: nowMs() + settings.nightSec * 1000,
      awakeRole: ROLES.KILLER
    });

    speakTR("Gece oldu. Katiller uyanıyor.");
  }

  async function resolveVotingAuto(votes){
    settings = await readSettings();
    const alive = aliveUids(players);
    const maj = strictMajority(alive.length);

    const { best, bestCount, tie } = tallyMost(votes);

    // kimse elenmedi
    if (!best || tie || best === ACTIONS.SKIP_VOTE || bestCount < maj) {
      await update(stateRef(roomCode), {
        phase: PHASE.NIGHT_KILL,
        hostText: "Oylama bitti. Kimse elenmedi. Gece oluyor.",
        timerEndsAt: nowMs() + settings.nightSec * 1000,
        awakeRole: ROLES.KILLER
      });
      await set(votingVotesRef(roomCode), null);
      await set(requestVoteStartRef(roomCode), null);
      speakTR("Oylama bitti. Kimse elenmedi. Gece oluyor.");
      return;
    }

    // ele
    const name = players?.[best]?.name || "Bir oyuncu";
    await update(playerRef(roomCode, best), { alive: false, eliminatedAt: nowMs() });

    const roles = await readSecretRoles();
    const playersSnap = await get(playersRef(roomCode));
    const freshPlayers = playersSnap.exists() ? (playersSnap.val()||{}) : players;

    const win = computeWin(freshPlayers, roles);

    if (win.ended) {
      const txt = win.winner === "TOWN"
        ? `${name} elendi. Vatandaşlar kazandı.`
        : `${name} elendi. Katiller kazandı.`;

      await update(stateRef(roomCode), {
        phase: PHASE.ENDED,
        hostText: txt,
        timerEndsAt: null,
        revealAtEnd: true
      });
      speakTR(txt);
      return;
    }

    // geceye geç
    await update(stateRef(roomCode), {
      phase: PHASE.NIGHT_KILL,
      hostText: `${name} elendi. Gece oluyor.`,
      timerEndsAt: nowMs() + settings.nightSec * 1000,
      awakeRole: ROLES.KILLER
    });

    await set(votingVotesRef(roomCode), null);
    await set(requestVoteStartRef(roomCode), null);

    speakTR(`${name} elendi. Gece oluyor.`);
  }

  async function advanceNightStageAuto(actions, roles){
    settings = await readSettings();

    if (state.phase === PHASE.NIGHT_KILL) {
      // doktor varsa -> doctor, yoksa detective, yoksa resolve
      if (settings.includeDoctor) {
        await update(stateRef(roomCode), {
          phase: PHASE.NIGHT_DOCTOR,
          hostText: "Doktor uyanıyor.",
          timerEndsAt: nowMs() + settings.nightSec * 1000,
          awakeRole: ROLES.DOCTOR
        });
        speakTR("Doktor uyanıyor.");
        return;
      }
      if (settings.includeDetective) {
        await update(stateRef(roomCode), {
          phase: PHASE.NIGHT_DETECTIVE,
          hostText: "Dedektif uyanıyor.",
          timerEndsAt: nowMs() + settings.nightSec * 1000,
          awakeRole: ROLES.DETECTIVE
        });
        speakTR("Dedektif uyanıyor.");
        return;
      }
      return resolveWholeNight(actions, roles);
    }

    if (state.phase === PHASE.NIGHT_DOCTOR) {
      if (settings.includeDetective) {
        await update(stateRef(roomCode), {
          phase: PHASE.NIGHT_DETECTIVE,
          hostText: "Dedektif uyanıyor.",
          timerEndsAt: nowMs() + settings.nightSec * 1000,
          awakeRole: ROLES.DETECTIVE
        });
        speakTR("Dedektif uyanıyor.");
        return;
      }
      return resolveWholeNight(actions, roles);
    }

    if (state.phase === PHASE.NIGHT_DETECTIVE) {
      return resolveWholeNight(actions, roles);
    }
  }

  async function resolveWholeNight(actions, roles){
    // resolve kill target by killer majority (tie-> NO_KILL if allowNoKill)
    const killMap = actions?.kill || {};
    const protectMap = actions?.protect || {};
    const investigateMap = actions?.investigate || {};

    // tally kill (ignore NO_KILL)
    const map = new Map();
    for (const v of Object.values(killMap)) {
      if (!v) continue;
      if (v === ACTIONS.NO_KILL) continue;
      map.set(v, (map.get(v)||0) + 1);
    }
    let killTargetUid = null, best=0, tie=false;
    for (const [k,c] of map.entries()){
      if (c>best){ best=c; killTargetUid=k; tie=false; }
      else if (c===best){ tie=true; }
    }
    if (tie) killTargetUid = settings.allowNoKill ? ACTIONS.NO_KILL : null;

    // doctor (first valid)
    let doctorUid=null, doctorSaveUid=null;
    for (const [uid,t] of Object.entries(protectMap||{})){
      if (!t) continue;
      doctorUid = uid;
      doctorSaveUid = t;
      break;
    }

    // doctor self-save limit check (host enforces)
    if (doctorUid && doctorSaveUid && doctorUid === doctorSaveUid) {
      const used = Number(players?.[doctorUid]?.doctorSelfProtectUsed || 0);
      if (used >= Number(settings.doctorSelfSaveMax || 0)) {
        // limit dolu -> self save iptal
        doctorSaveUid = null;
      }
    }

    const usedNow = Number(players?.[doctorUid]?.doctorSelfProtectUsed || 0);

    const nightRes = resolveNight({
      killTargetUid,
      doctorSaveUid,
      doctorUid,
      doctorSelfUsed: usedNow,
      settings
    });

    // if self-save used successfully -> increment
    if (nightRes.reason === "DOCTOR_SELF_SAVE" && doctorUid && doctorSaveUid === doctorUid) {
      await update(playerRef(roomCode, doctorUid), { doctorSelfProtectUsed: usedNow + 1 });
    }

    // apply death
    let deadUid = null;
    if (nightRes.diedUid) {
      deadUid = nightRes.diedUid;
      await update(playerRef(roomCode, deadUid), { alive: false, diedAt: nowMs() });
    }

    // detective inbox
    for (const [detUid, targetUid] of Object.entries(investigateMap||{})) {
      if (!targetUid) continue;
      const targetRole = roles?.[targetUid]?.role || "UNKNOWN";
      const msg = `${players?.[targetUid]?.name || "Oyuncu"} rolü: ${ROLE_TR[targetRole] || targetRole}`;
      await update(secretRoleRef(roomCode, detUid), { inbox: { t: nowMs(), msg } });
    }

    // public night result
    const deadName = deadUid ? (players?.[deadUid]?.name || "Bir oyuncu") : null;
    const morningText = deadUid
      ? `Sabah oldu. ${deadName} ölü bulundu.`
      : "Sabah oldu. Bu gece kimse ölmedi.";

    await set(nightResultsRef(roomCode), {
      t: nowMs(),
      deadUid: deadUid || null,
      deadName: deadName || null,
      reason: nightRes.reason,
      saved: !!nightRes.saved,
      killAttempted: !!killTargetUid
    });

    // win check (fresh)
    const [playersSnap] = await Promise.all([ get(playersRef(roomCode)) ]);
    const freshPlayers = playersSnap.exists() ? (playersSnap.val()||{}) : players;

    const win = computeWin(freshPlayers, roles);

    if (win.ended) {
      const txt = win.winner === "TOWN"
        ? "Oyun bitti. Vatandaşlar kazandı."
        : "Oyun bitti. Katiller kazandı.";

      await update(stateRef(roomCode), {
        phase: PHASE.ENDED,
        hostText: txt,
        timerEndsAt: null,
        awakeRole: null,
        revealAtEnd: true
      });

      speakTR(txt);
      return;
    }

    // morning -> short pause then discussion next day
    await update(stateRef(roomCode), {
      phase: PHASE.MORNING,
      hostText: morningText,
      timerEndsAt: nowMs() + 4000,
      awakeRole: null
    });
    speakTR(morningText);
  }

  async function startDiscussionNextDayAuto(){
    settings = await readSettings();
    const day = Number(state?.day || 1) + 1;

    await update(stateRef(roomCode), {
      phase: PHASE.DISCUSSION,
      day,
      hostText: `Gün ${day}: Tartışma başladı.`,
      timerEndsAt: nowMs() + settings.discussionSec * 1000
    });
    // request reset
    await set(requestFastNightRef(roomCode), null);
    await set(requestVoteStartRef(roomCode), null);

    speakTR(`Gün ${day}. Tartışma başladı.`);
  }

  // -------- events ----------
  el("btnCreate").addEventListener("click", createRoom);
  el("btnStart").addEventListener("click", startGame);

  // init
  ensureAuth().then(()=>showSetup());
</script>

</body>
</html>
